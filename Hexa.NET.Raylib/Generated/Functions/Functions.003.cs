// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Raylib
{
	public unsafe partial class Raylib
	{

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int*")] int* codepointSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetCodepointPreviousNative(pStr0, codepointSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int*")] ref int codepointSize)
		{
			fixed (int* pcodepointSize = &codepointSize)
			{
				int ret = GetCodepointPreviousNative(text, (int*)pcodepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int*")] ref int codepointSize)
		{
			fixed (byte* ptext = &text)
			{
				fixed (int* pcodepointSize = &codepointSize)
				{
					int ret = GetCodepointPreviousNative((byte*)ptext, (int*)pcodepointSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int*")] ref int codepointSize)
		{
			fixed (byte* ptext = text)
			{
				fixed (int* pcodepointSize = &codepointSize)
				{
					int ret = GetCodepointPreviousNative((byte*)ptext, (int*)pcodepointSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int*")] ref int codepointSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcodepointSize = &codepointSize)
			{
				int ret = GetCodepointPreviousNative(pStr0, (int*)pcodepointSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* CodepointToUTF8Native([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int*")] int* utf8Size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int*, byte*>)vt[415])(codepoint, utf8Size);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint, nint>)vt[415])(codepoint, (nint)utf8Size);
			#endif
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* CodepointToUTF8([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int*")] int* utf8Size)
		{
			byte* ret = CodepointToUTF8Native(codepoint, utf8Size);
			return ret;
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string CodepointToUTF8S([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int*")] int* utf8Size)
		{
			string ret = Utils.DecodeStringUTF8(CodepointToUTF8Native(codepoint, utf8Size));
			return ret;
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* CodepointToUTF8([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int*")] ref int utf8Size)
		{
			fixed (int* putf8Size = &utf8Size)
			{
				byte* ret = CodepointToUTF8Native(codepoint, (int*)putf8Size);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string CodepointToUTF8S([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int*")] ref int utf8Size)
		{
			fixed (int* putf8Size = &utf8Size)
			{
				string ret = Utils.DecodeStringUTF8(CodepointToUTF8Native(codepoint, (int*)putf8Size));
				return ret;
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int TextCopyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)vt[416])(dst, src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[416])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src)
		{
			int ret = TextCopyNative(dst, src);
			return ret;
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src)
		{
			fixed (byte* pdst = &dst)
			{
				int ret = TextCopyNative((byte*)pdst, src);
				return ret;
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextCopyNative(pStr0, src);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ref byte src)
		{
			fixed (byte* psrc = &src)
			{
				int ret = TextCopyNative(dst, (byte*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> src)
		{
			fixed (byte* psrc = src)
			{
				int ret = TextCopyNative(dst, (byte*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] string src)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextCopyNative(dst, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ref byte src)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					int ret = TextCopyNative((byte*)pdst, (byte*)psrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> src)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					int ret = TextCopyNative((byte*)pdst, (byte*)psrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// NOTE: Some strings allocate memory internally for returned strings, just be careful!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] string src)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = TextCopyNative(pStr0, pStr1);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TextIsEqualNative([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] byte* text2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)vt[417])(text1, text2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)vt[417])((nint)text1, (nint)text2);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] byte* text2)
		{
			byte ret = TextIsEqualNative(text1, text2);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] ref byte text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] byte* text2)
		{
			fixed (byte* ptext1 = &text1)
			{
				byte ret = TextIsEqualNative((byte*)ptext1, text2);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] byte* text2)
		{
			fixed (byte* ptext1 = text1)
			{
				byte ret = TextIsEqualNative((byte*)ptext1, text2);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] string text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] byte* text2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TextIsEqualNative(pStr0, text2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] ref byte text2)
		{
			fixed (byte* ptext2 = &text2)
			{
				byte ret = TextIsEqualNative(text1, (byte*)ptext2);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text2)
		{
			fixed (byte* ptext2 = text2)
			{
				byte ret = TextIsEqualNative(text1, (byte*)ptext2);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] string text2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TextIsEqualNative(text1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] ref byte text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] ref byte text2)
		{
			fixed (byte* ptext1 = &text1)
			{
				fixed (byte* ptext2 = &text2)
				{
					byte ret = TextIsEqualNative((byte*)ptext1, (byte*)ptext2);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text2)
		{
			fixed (byte* ptext1 = text1)
			{
				fixed (byte* ptext2 = text2)
				{
					byte ret = TextIsEqualNative((byte*)ptext1, (byte*)ptext2);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "const char*")] string text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "const char*")] string text2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (text2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(text2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(text2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TextIsEqualNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		internal static uint TextLengthNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint>)vt[418])(text);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)vt[418])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint TextLength([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			uint ret = TextLengthNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint TextLength([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				uint ret = TextLengthNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint TextLength([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				uint ret = TextLengthNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint TextLength([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = TextLengthNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* TextFormatNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)vt[419])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[419])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextFormat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			byte* ret = TextFormatNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextFormatS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextFormatNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextFormat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextFormatNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextFormatS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextFormatNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextFormat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextFormatNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextFormatS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextFormatNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextFormat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextFormatNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextFormatS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextFormatNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* TextSubtextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int, byte*>)vt[420])(text, position, length);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)vt[420])((nint)text, position, length);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextSubtext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* ret = TextSubtextNative(text, position, length);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextSubtextS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			string ret = Utils.DecodeStringUTF8(TextSubtextNative(text, position, length));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextSubtext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextSubtextNative((byte*)ptext, position, length);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextSubtextS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextSubtextNative((byte*)ptext, position, length));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextSubtext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextSubtextNative((byte*)ptext, position, length);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextSubtextS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextSubtextNative((byte*)ptext, position, length));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextSubtext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextSubtextNative(pStr0, position, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextSubtextS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextSubtextNative(pStr0, position, length));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		internal static byte* TextReplaceNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, byte*>)vt[421])(text, replace, by);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint>)vt[421])((nint)text, (nint)replace, (nint)by);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			byte* ret = TextReplaceNative(text, replace, by);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, replace, by));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextReplaceNative((byte*)ptext, replace, by);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, replace, by));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextReplaceNative((byte*)ptext, replace, by);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, replace, by));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextReplaceNative(pStr0, replace, by);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(pStr0, replace, by));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* preplace = &replace)
			{
				byte* ret = TextReplaceNative(text, (byte*)preplace, by);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* preplace = &replace)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, (byte*)preplace, by));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* preplace = replace)
			{
				byte* ret = TextReplaceNative(text, (byte*)preplace, by);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* preplace = replace)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, (byte*)preplace, by));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (replace != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(replace);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(replace, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextReplaceNative(text, pStr0, by);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (replace != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(replace);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(replace, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, pStr0, by));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* preplace = &replace)
				{
					byte* ret = TextReplaceNative((byte*)ptext, (byte*)preplace, by);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* preplace = &replace)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, (byte*)preplace, by));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* preplace = replace)
				{
					byte* ret = TextReplaceNative((byte*)ptext, (byte*)preplace, by);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* preplace = replace)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, (byte*)preplace, by));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (replace != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(replace);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(replace, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = TextReplaceNative(pStr0, pStr1, by);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (replace != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(replace);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(replace, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(pStr0, pStr1, by));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ref byte by)
		{
			fixed (byte* pby = &by)
			{
				byte* ret = TextReplaceNative(text, replace, (byte*)pby);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ref byte by)
		{
			fixed (byte* pby = &by)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, replace, (byte*)pby));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> by)
		{
			fixed (byte* pby = by)
			{
				byte* ret = TextReplaceNative(text, replace, (byte*)pby);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> by)
		{
			fixed (byte* pby = by)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, replace, (byte*)pby));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (by != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(by);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(by, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextReplaceNative(text, replace, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (by != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(by);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(by, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, replace, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ref byte by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pby = &by)
				{
					byte* ret = TextReplaceNative((byte*)ptext, replace, (byte*)pby);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ref byte by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pby = &by)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, replace, (byte*)pby));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pby = by)
				{
					byte* ret = TextReplaceNative((byte*)ptext, replace, (byte*)pby);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pby = by)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, replace, (byte*)pby));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (by != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(by);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(by, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = TextReplaceNative(pStr0, replace, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (by != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(by);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(by, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(pStr0, replace, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ref byte by)
		{
			fixed (byte* preplace = &replace)
			{
				fixed (byte* pby = &by)
				{
					byte* ret = TextReplaceNative(text, (byte*)preplace, (byte*)pby);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ref byte by)
		{
			fixed (byte* preplace = &replace)
			{
				fixed (byte* pby = &by)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, (byte*)preplace, (byte*)pby));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> by)
		{
			fixed (byte* preplace = replace)
			{
				fixed (byte* pby = by)
				{
					byte* ret = TextReplaceNative(text, (byte*)preplace, (byte*)pby);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> by)
		{
			fixed (byte* preplace = replace)
			{
				fixed (byte* pby = by)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, (byte*)preplace, (byte*)pby));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (replace != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(replace);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(replace, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (by != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(by);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(by, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = TextReplaceNative(text, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (replace != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(replace);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(replace, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (by != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(by);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(by, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ref byte by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* preplace = &replace)
				{
					fixed (byte* pby = &by)
					{
						byte* ret = TextReplaceNative((byte*)ptext, (byte*)preplace, (byte*)pby);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ref byte by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* preplace = &replace)
				{
					fixed (byte* pby = &by)
					{
						string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, (byte*)preplace, (byte*)pby));
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* preplace = replace)
				{
					fixed (byte* pby = by)
					{
						byte* ret = TextReplaceNative((byte*)ptext, (byte*)preplace, (byte*)pby);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* preplace = replace)
				{
					fixed (byte* pby = by)
					{
						string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, (byte*)preplace, (byte*)pby));
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (replace != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(replace);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(replace, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (by != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(by);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(by, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = TextReplaceNative(pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "const char*")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "const char*")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (replace != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(replace);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(replace, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (by != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(by);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(by, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(pStr0, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		internal static byte* TextInsertNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, byte*>)vt[422])(text, insert, position);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)vt[422])((nint)text, (nint)insert, position);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* ret = TextInsertNative(text, insert, position);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			string ret = Utils.DecodeStringUTF8(TextInsertNative(text, insert, position));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextInsertNative((byte*)ptext, insert, position);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextInsertNative((byte*)ptext, insert, position));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextInsertNative((byte*)ptext, insert, position);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextInsertNative((byte*)ptext, insert, position));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextInsertNative(pStr0, insert, position);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextInsertNative(pStr0, insert, position));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] ref byte insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* pinsert = &insert)
			{
				byte* ret = TextInsertNative(text, (byte*)pinsert, position);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] ref byte insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* pinsert = &insert)
			{
				string ret = Utils.DecodeStringUTF8(TextInsertNative(text, (byte*)pinsert, position));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* pinsert = insert)
			{
				byte* ret = TextInsertNative(text, (byte*)pinsert, position);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* pinsert = insert)
			{
				string ret = Utils.DecodeStringUTF8(TextInsertNative(text, (byte*)pinsert, position));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] string insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (insert != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(insert);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(insert, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextInsertNative(text, pStr0, position);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] string insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (insert != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(insert);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(insert, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextInsertNative(text, pStr0, position));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] ref byte insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pinsert = &insert)
				{
					byte* ret = TextInsertNative((byte*)ptext, (byte*)pinsert, position);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] ref byte insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pinsert = &insert)
				{
					string ret = Utils.DecodeStringUTF8(TextInsertNative((byte*)ptext, (byte*)pinsert, position));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pinsert = insert)
				{
					byte* ret = TextInsertNative((byte*)ptext, (byte*)pinsert, position);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pinsert = insert)
				{
					string ret = Utils.DecodeStringUTF8(TextInsertNative((byte*)ptext, (byte*)pinsert, position));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] string insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (insert != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(insert);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(insert, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = TextInsertNative(pStr0, pStr1, position);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "const char*")] string insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (insert != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(insert);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(insert, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextInsertNative(pStr0, pStr1, position));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* TextJoinNative([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] byte* delimiter)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, int, byte*, byte*>)vt[423])(textList, count, delimiter);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)vt[423])((nint)textList, count, (nint)delimiter);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] byte* delimiter)
		{
			byte* ret = TextJoinNative(textList, count, delimiter);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] byte* delimiter)
		{
			string ret = Utils.DecodeStringUTF8(TextJoinNative(textList, count, delimiter));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] byte* delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				byte* ret = TextJoinNative((byte**)ptextList, count, delimiter);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] byte* delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				string ret = Utils.DecodeStringUTF8(TextJoinNative((byte**)ptextList, count, delimiter));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] ref byte delimiter)
		{
			fixed (byte* pdelimiter = &delimiter)
			{
				byte* ret = TextJoinNative(textList, count, (byte*)pdelimiter);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] ref byte delimiter)
		{
			fixed (byte* pdelimiter = &delimiter)
			{
				string ret = Utils.DecodeStringUTF8(TextJoinNative(textList, count, (byte*)pdelimiter));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> delimiter)
		{
			fixed (byte* pdelimiter = delimiter)
			{
				byte* ret = TextJoinNative(textList, count, (byte*)pdelimiter);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> delimiter)
		{
			fixed (byte* pdelimiter = delimiter)
			{
				string ret = Utils.DecodeStringUTF8(TextJoinNative(textList, count, (byte*)pdelimiter));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] string delimiter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (delimiter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(delimiter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(delimiter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextJoinNative(textList, count, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] string delimiter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (delimiter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(delimiter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(delimiter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextJoinNative(textList, count, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] ref byte delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				fixed (byte* pdelimiter = &delimiter)
				{
					byte* ret = TextJoinNative((byte**)ptextList, count, (byte*)pdelimiter);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] ref byte delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				fixed (byte* pdelimiter = &delimiter)
				{
					string ret = Utils.DecodeStringUTF8(TextJoinNative((byte**)ptextList, count, (byte*)pdelimiter));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				fixed (byte* pdelimiter = delimiter)
				{
					byte* ret = TextJoinNative((byte**)ptextList, count, (byte*)pdelimiter);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				fixed (byte* pdelimiter = delimiter)
				{
					string ret = Utils.DecodeStringUTF8(TextJoinNative((byte**)ptextList, count, (byte*)pdelimiter));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] string delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (delimiter != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(delimiter);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(delimiter, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = TextJoinNative((byte**)ptextList, count, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "const char**")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "const char*")] string delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (delimiter != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(delimiter);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(delimiter, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(TextJoinNative((byte**)ptextList, count, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void TextAppendNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, int*, void>)vt[424])(text, append, position);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)vt[424])((nint)text, (nint)append, (nint)position);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			TextAppendNative(text, append, position);
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			fixed (byte* ptext = &text)
			{
				TextAppendNative((byte*)ptext, append, position);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref string text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextAppendNative(pStr0, append, position);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] ref byte append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			fixed (byte* pappend = &append)
			{
				TextAppendNative(text, (byte*)pappend, position);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			fixed (byte* pappend = append)
			{
				TextAppendNative(text, (byte*)pappend, position);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] string append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (append != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(append);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(append, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextAppendNative(text, pStr0, position);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] ref byte append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pappend = &append)
				{
					TextAppendNative((byte*)ptext, (byte*)pappend, position);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pappend = append)
				{
					TextAppendNative((byte*)ptext, (byte*)pappend, position);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref string text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] string append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] int* position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (append != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(append);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(append, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			TextAppendNative(pStr0, pStr1, position);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			fixed (int* pposition = &position)
			{
				TextAppendNative(text, append, (int*)pposition);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (int* pposition = &position)
				{
					TextAppendNative((byte*)ptext, append, (int*)pposition);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref string text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pposition = &position)
			{
				TextAppendNative(pStr0, append, (int*)pposition);
				text = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] ref byte append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			fixed (byte* pappend = &append)
			{
				fixed (int* pposition = &position)
				{
					TextAppendNative(text, (byte*)pappend, (int*)pposition);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			fixed (byte* pappend = append)
			{
				fixed (int* pposition = &position)
				{
					TextAppendNative(text, (byte*)pappend, (int*)pposition);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] string append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (append != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(append);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(append, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pposition = &position)
			{
				TextAppendNative(text, pStr0, (int*)pposition);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] ref byte append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pappend = &append)
				{
					fixed (int* pposition = &position)
					{
						TextAppendNative((byte*)ptext, (byte*)pappend, (int*)pposition);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pappend = append)
				{
					fixed (int* pposition = &position)
					{
						TextAppendNative((byte*)ptext, (byte*)pappend, (int*)pposition);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref string text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "const char*")] string append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int*")] ref int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (append != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(append);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(append, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (int* pposition = &position)
			{
				TextAppendNative(pStr0, pStr1, (int*)pposition);
				text = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int TextFindIndexNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] byte* find)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)vt[425])(text, find);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[425])((nint)text, (nint)find);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] byte* find)
		{
			int ret = TextFindIndexNative(text, find);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] byte* find)
		{
			fixed (byte* ptext = &text)
			{
				int ret = TextFindIndexNative((byte*)ptext, find);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] byte* find)
		{
			fixed (byte* ptext = text)
			{
				int ret = TextFindIndexNative((byte*)ptext, find);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] byte* find)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextFindIndexNative(pStr0, find);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] ref byte find)
		{
			fixed (byte* pfind = &find)
			{
				int ret = TextFindIndexNative(text, (byte*)pfind);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> find)
		{
			fixed (byte* pfind = find)
			{
				int ret = TextFindIndexNative(text, (byte*)pfind);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] string find)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (find != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(find);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(find, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextFindIndexNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] ref byte find)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfind = &find)
				{
					int ret = TextFindIndexNative((byte*)ptext, (byte*)pfind);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> find)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pfind = find)
				{
					int ret = TextFindIndexNative((byte*)ptext, (byte*)pfind);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "const char*")] string find)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (find != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(find);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(find, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = TextFindIndexNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* TextToUpperNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)vt[426])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[426])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToUpper([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			byte* ret = TextToUpperNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToUpperS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToUpperNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToUpper([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToUpperNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToUpperS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToUpperNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToUpper([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToUpperNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToUpperS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToUpperNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToUpper([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToUpperNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToUpperS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToUpperNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* TextToLowerNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)vt[427])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[427])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToLower([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			byte* ret = TextToLowerNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToLowerS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToLowerNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToLower([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToLowerNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToLowerS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToLowerNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToLower([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToLowerNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToLowerS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToLowerNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToLower([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToLowerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToLowerS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToLowerNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* TextToPascalNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)vt[428])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[428])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToPascal([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			byte* ret = TextToPascalNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToPascalS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToPascalNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToPascal([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToPascalNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToPascalS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToPascalNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToPascal([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToPascalNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToPascalS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToPascalNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToPascal([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToPascalNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToPascalS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToPascalNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* TextToSnakeNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)vt[429])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[429])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToSnake([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			byte* ret = TextToSnakeNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToSnakeS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToSnakeNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToSnake([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToSnakeNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToSnakeS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToSnakeNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToSnake([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToSnakeNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToSnakeS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToSnakeNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToSnake([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToSnakeNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToSnakeS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToSnakeNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* TextToCamelNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)vt[430])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[430])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToCamel([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			byte* ret = TextToCamelNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToCamelS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToCamelNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToCamel([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToCamelNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToCamelS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToCamelNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToCamel([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToCamelNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToCamelS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToCamelNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* TextToCamel([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToCamelNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string TextToCamelS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToCamelNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int TextToIntegerNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)vt[431])(text);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[431])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextToInteger([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			int ret = TextToIntegerNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextToInteger([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = TextToIntegerNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextToInteger([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				int ret = TextToIntegerNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextToInteger([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextToIntegerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		internal static float TextToFloatNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, float>)vt[432])(text);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)vt[432])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TextToFloat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			float ret = TextToFloatNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TextToFloat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				float ret = TextToFloatNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TextToFloat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				float ret = TextToFloatNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TextToFloat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			float ret = TextToFloatNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Basic geometric 3D shapes drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawLine3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawLine3DNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)vt[433])(startPos, endPos, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)vt[433])(startPos, endPos, color);
			#endif
		}

		/// <summary>
		/// Basic geometric 3D shapes drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawLine3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawLine3D([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawLine3DNative(startPos, endPos, color);
		}

		[NativeName(NativeNameType.Func, "DrawPoint3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawPoint3DNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Color, void>)vt[434])(position, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Color, void>)vt[434])(position, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawPoint3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawPoint3D([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawPoint3DNative(position, color);
		}

		[NativeName(NativeNameType.Func, "DrawCircle3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCircle3DNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotationAxis")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotationAxis, [NativeName(NativeNameType.Param, "rotationAngle")] [NativeName(NativeNameType.Type, "float")] float rotationAngle, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, Vector3, float, Color, void>)vt[435])(center, radius, rotationAxis, rotationAngle, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, Vector3, float, Color, void>)vt[435])(center, radius, rotationAxis, rotationAngle, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircle3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircle3D([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotationAxis")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotationAxis, [NativeName(NativeNameType.Param, "rotationAngle")] [NativeName(NativeNameType.Type, "float")] float rotationAngle, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCircle3DNative(center, radius, rotationAxis, rotationAngle, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangle3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawTriangle3DNative([NativeName(NativeNameType.Param, "v1")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v1, [NativeName(NativeNameType.Param, "v2")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v2, [NativeName(NativeNameType.Param, "v3")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v3, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Vector3, Color, void>)vt[436])(v1, v2, v3, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Vector3, Color, void>)vt[436])(v1, v2, v3, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawTriangle3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangle3D([NativeName(NativeNameType.Param, "v1")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v1, [NativeName(NativeNameType.Param, "v2")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v2, [NativeName(NativeNameType.Param, "v3")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v3, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawTriangle3DNative(v1, v2, v3, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawTriangleStrip3DNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const Vector3*")] Vector3* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, int, Color, void>)vt[437])(points, pointCount, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, Color, void>)vt[437])((nint)points, pointCount, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleStrip3D([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const Vector3*")] Vector3* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawTriangleStrip3DNative(points, pointCount, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleStrip3D([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const Vector3*")] ref Vector3 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector3* ppoints = &points)
			{
				DrawTriangleStrip3DNative((Vector3*)ppoints, pointCount, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawCube")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCubeNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, Color, void>)vt[438])(position, width, height, length, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, Color, void>)vt[438])(position, width, height, length, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCube")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCube([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCubeNative(position, width, height, length, color);
		}

		[NativeName(NativeNameType.Func, "DrawCubeV")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCubeVNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)vt[439])(position, size, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)vt[439])(position, size, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCubeV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCubeV([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCubeVNative(position, size, color);
		}

		[NativeName(NativeNameType.Func, "DrawCubeWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCubeWiresNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, Color, void>)vt[440])(position, width, height, length, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, Color, void>)vt[440])(position, width, height, length, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCubeWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCubeWires([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCubeWiresNative(position, width, height, length, color);
		}

		[NativeName(NativeNameType.Func, "DrawCubeWiresV")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCubeWiresVNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)vt[441])(position, size, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)vt[441])(position, size, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCubeWiresV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCubeWiresV([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCubeWiresVNative(position, size, color);
		}

		[NativeName(NativeNameType.Func, "DrawSphere")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawSphereNative([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, Color, void>)vt[442])(centerPos, radius, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, Color, void>)vt[442])(centerPos, radius, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSphere")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSphere([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSphereNative(centerPos, radius, color);
		}

		[NativeName(NativeNameType.Func, "DrawSphereEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawSphereExNative([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, int, int, Color, void>)vt[443])(centerPos, radius, rings, slices, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, int, int, Color, void>)vt[443])(centerPos, radius, rings, slices, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSphereEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSphereEx([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSphereExNative(centerPos, radius, rings, slices, color);
		}

		[NativeName(NativeNameType.Func, "DrawSphereWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawSphereWiresNative([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, int, int, Color, void>)vt[444])(centerPos, radius, rings, slices, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, int, int, Color, void>)vt[444])(centerPos, radius, rings, slices, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSphereWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSphereWires([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSphereWiresNative(centerPos, radius, rings, slices, color);
		}

		[NativeName(NativeNameType.Func, "DrawCylinder")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCylinderNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "radiusTop")] [NativeName(NativeNameType.Type, "float")] float radiusTop, [NativeName(NativeNameType.Param, "radiusBottom")] [NativeName(NativeNameType.Type, "float")] float radiusBottom, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, int, Color, void>)vt[445])(position, radiusTop, radiusBottom, height, slices, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, int, Color, void>)vt[445])(position, radiusTop, radiusBottom, height, slices, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCylinder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCylinder([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "radiusTop")] [NativeName(NativeNameType.Type, "float")] float radiusTop, [NativeName(NativeNameType.Param, "radiusBottom")] [NativeName(NativeNameType.Type, "float")] float radiusBottom, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCylinderNative(position, radiusTop, radiusBottom, height, slices, color);
		}

		[NativeName(NativeNameType.Func, "DrawCylinderEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCylinderExNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "startRadius")] [NativeName(NativeNameType.Type, "float")] float startRadius, [NativeName(NativeNameType.Param, "endRadius")] [NativeName(NativeNameType.Type, "float")] float endRadius, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, float, int, Color, void>)vt[446])(startPos, endPos, startRadius, endRadius, sides, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, float, int, Color, void>)vt[446])(startPos, endPos, startRadius, endRadius, sides, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCylinderEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCylinderEx([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "startRadius")] [NativeName(NativeNameType.Type, "float")] float startRadius, [NativeName(NativeNameType.Param, "endRadius")] [NativeName(NativeNameType.Type, "float")] float endRadius, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCylinderExNative(startPos, endPos, startRadius, endRadius, sides, color);
		}

		[NativeName(NativeNameType.Func, "DrawCylinderWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCylinderWiresNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "radiusTop")] [NativeName(NativeNameType.Type, "float")] float radiusTop, [NativeName(NativeNameType.Param, "radiusBottom")] [NativeName(NativeNameType.Type, "float")] float radiusBottom, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, int, Color, void>)vt[447])(position, radiusTop, radiusBottom, height, slices, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, int, Color, void>)vt[447])(position, radiusTop, radiusBottom, height, slices, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCylinderWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCylinderWires([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "radiusTop")] [NativeName(NativeNameType.Type, "float")] float radiusTop, [NativeName(NativeNameType.Param, "radiusBottom")] [NativeName(NativeNameType.Type, "float")] float radiusBottom, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCylinderWiresNative(position, radiusTop, radiusBottom, height, slices, color);
		}

		[NativeName(NativeNameType.Func, "DrawCylinderWiresEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCylinderWiresExNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "startRadius")] [NativeName(NativeNameType.Type, "float")] float startRadius, [NativeName(NativeNameType.Param, "endRadius")] [NativeName(NativeNameType.Type, "float")] float endRadius, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, float, int, Color, void>)vt[448])(startPos, endPos, startRadius, endRadius, sides, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, float, int, Color, void>)vt[448])(startPos, endPos, startRadius, endRadius, sides, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCylinderWiresEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCylinderWiresEx([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "startRadius")] [NativeName(NativeNameType.Type, "float")] float startRadius, [NativeName(NativeNameType.Param, "endRadius")] [NativeName(NativeNameType.Type, "float")] float endRadius, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCylinderWiresExNative(startPos, endPos, startRadius, endRadius, sides, color);
		}

		[NativeName(NativeNameType.Func, "DrawCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCapsuleNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, int, int, Color, void>)vt[449])(startPos, endPos, radius, slices, rings, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, int, int, Color, void>)vt[449])(startPos, endPos, radius, slices, rings, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCapsule([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCapsuleNative(startPos, endPos, radius, slices, rings, color);
		}

		[NativeName(NativeNameType.Func, "DrawCapsuleWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawCapsuleWiresNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, int, int, Color, void>)vt[450])(startPos, endPos, radius, slices, rings, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, int, int, Color, void>)vt[450])(startPos, endPos, radius, slices, rings, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCapsuleWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCapsuleWires([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCapsuleWiresNative(startPos, endPos, radius, slices, rings, color);
		}

		[NativeName(NativeNameType.Func, "DrawPlane")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawPlaneNative([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector2, Color, void>)vt[451])(centerPos, size, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector2, Color, void>)vt[451])(centerPos, size, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawPlane")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawPlane([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawPlaneNative(centerPos, size, color);
		}

		[NativeName(NativeNameType.Func, "DrawRay")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawRayNative([NativeName(NativeNameType.Param, "ray")] [NativeName(NativeNameType.Type, "Ray")] Ray ray, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Ray, Color, void>)vt[452])(ray, color);
			#else
			((delegate* unmanaged[Cdecl]<Ray, Color, void>)vt[452])(ray, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRay([NativeName(NativeNameType.Param, "ray")] [NativeName(NativeNameType.Type, "Ray")] Ray ray, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRayNative(ray, color);
		}

		[NativeName(NativeNameType.Func, "DrawGrid")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawGridNative([NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "spacing")] [NativeName(NativeNameType.Type, "float")] float spacing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[453])(slices, spacing);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[453])(slices, spacing);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawGrid")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGrid([NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "spacing")] [NativeName(NativeNameType.Type, "float")] float spacing)
		{
			DrawGridNative(slices, spacing);
		}

		/// <summary>
		/// Model management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadModel")]
		[return: NativeName(NativeNameType.Type, "Model")]
		internal static Model LoadModelNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Model>)vt[454])(fileName);
			#else
			return (Model)((delegate* unmanaged[Cdecl]<nint, Model>)vt[454])((nint)fileName);
			#endif
		}

		/// <summary>
		/// Model management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadModel")]
		[return: NativeName(NativeNameType.Type, "Model")]
		public static Model LoadModel([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] byte* fileName)
		{
			Model ret = LoadModelNative(fileName);
			return ret;
		}

		/// <summary>
		/// Model management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadModel")]
		[return: NativeName(NativeNameType.Type, "Model")]
		public static Model LoadModel([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				Model ret = LoadModelNative((byte*)pfileName);
				return ret;
			}
		}

		/// <summary>
		/// Model management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadModel")]
		[return: NativeName(NativeNameType.Type, "Model")]
		public static Model LoadModel([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				Model ret = LoadModelNative((byte*)pfileName);
				return ret;
			}
		}

		/// <summary>
		/// Model management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadModel")]
		[return: NativeName(NativeNameType.Type, "Model")]
		public static Model LoadModel([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Model ret = LoadModelNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadModelFromMesh")]
		[return: NativeName(NativeNameType.Type, "Model")]
		internal static Model LoadModelFromMeshNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Mesh, Model>)vt[455])(mesh);
			#else
			return (Model)((delegate* unmanaged[Cdecl]<Mesh, Model>)vt[455])(mesh);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadModelFromMesh")]
		[return: NativeName(NativeNameType.Type, "Model")]
		public static Model LoadModelFromMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh)
		{
			Model ret = LoadModelFromMeshNative(mesh);
			return ret;
		}

		[NativeName(NativeNameType.Func, "IsModelReady")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsModelReadyNative([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Model, byte>)vt[456])(model);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Model, byte>)vt[456])(model);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsModelReady")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsModelReady([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model)
		{
			byte ret = IsModelReadyNative(model);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "UnloadModel")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void UnloadModelNative([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Model, void>)vt[457])(model);
			#else
			((delegate* unmanaged[Cdecl]<Model, void>)vt[457])(model);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadModel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadModel([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model)
		{
			UnloadModelNative(model);
		}

		[NativeName(NativeNameType.Func, "GetModelBoundingBox")]
		[return: NativeName(NativeNameType.Type, "BoundingBox")]
		internal static BoundingBox GetModelBoundingBoxNative([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Model, BoundingBox>)vt[458])(model);
			#else
			return (BoundingBox)((delegate* unmanaged[Cdecl]<Model, BoundingBox>)vt[458])(model);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetModelBoundingBox")]
		[return: NativeName(NativeNameType.Type, "BoundingBox")]
		public static BoundingBox GetModelBoundingBox([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model)
		{
			BoundingBox ret = GetModelBoundingBoxNative(model);
			return ret;
		}

		/// <summary>
		/// Model drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawModel")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawModelNative([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Model, Vector3, float, Color, void>)vt[459])(model, position, scale, tint);
			#else
			((delegate* unmanaged[Cdecl]<Model, Vector3, float, Color, void>)vt[459])(model, position, scale, tint);
			#endif
		}

		/// <summary>
		/// Model drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawModel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawModel([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			DrawModelNative(model, position, scale, tint);
		}

		[NativeName(NativeNameType.Func, "DrawModelEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawModelExNative([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "rotationAxis")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotationAxis, [NativeName(NativeNameType.Param, "rotationAngle")] [NativeName(NativeNameType.Type, "float")] float rotationAngle, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Model, Vector3, Vector3, float, Vector3, Color, void>)vt[460])(model, position, rotationAxis, rotationAngle, scale, tint);
			#else
			((delegate* unmanaged[Cdecl]<Model, Vector3, Vector3, float, Vector3, Color, void>)vt[460])(model, position, rotationAxis, rotationAngle, scale, tint);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawModelEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawModelEx([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "rotationAxis")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotationAxis, [NativeName(NativeNameType.Param, "rotationAngle")] [NativeName(NativeNameType.Type, "float")] float rotationAngle, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			DrawModelExNative(model, position, rotationAxis, rotationAngle, scale, tint);
		}

		[NativeName(NativeNameType.Func, "DrawModelWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawModelWiresNative([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Model, Vector3, float, Color, void>)vt[461])(model, position, scale, tint);
			#else
			((delegate* unmanaged[Cdecl]<Model, Vector3, float, Color, void>)vt[461])(model, position, scale, tint);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawModelWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawModelWires([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			DrawModelWiresNative(model, position, scale, tint);
		}

		[NativeName(NativeNameType.Func, "DrawModelWiresEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawModelWiresExNative([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "rotationAxis")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotationAxis, [NativeName(NativeNameType.Param, "rotationAngle")] [NativeName(NativeNameType.Type, "float")] float rotationAngle, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Model, Vector3, Vector3, float, Vector3, Color, void>)vt[462])(model, position, rotationAxis, rotationAngle, scale, tint);
			#else
			((delegate* unmanaged[Cdecl]<Model, Vector3, Vector3, float, Vector3, Color, void>)vt[462])(model, position, rotationAxis, rotationAngle, scale, tint);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawModelWiresEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawModelWiresEx([NativeName(NativeNameType.Param, "model")] [NativeName(NativeNameType.Type, "Model")] Model model, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "rotationAxis")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotationAxis, [NativeName(NativeNameType.Param, "rotationAngle")] [NativeName(NativeNameType.Type, "float")] float rotationAngle, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			DrawModelWiresExNative(model, position, rotationAxis, rotationAngle, scale, tint);
		}

		[NativeName(NativeNameType.Func, "DrawBoundingBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawBoundingBoxNative([NativeName(NativeNameType.Param, "box")] [NativeName(NativeNameType.Type, "BoundingBox")] BoundingBox box, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<BoundingBox, Color, void>)vt[463])(box, color);
			#else
			((delegate* unmanaged[Cdecl]<BoundingBox, Color, void>)vt[463])(box, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawBoundingBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawBoundingBox([NativeName(NativeNameType.Param, "box")] [NativeName(NativeNameType.Type, "BoundingBox")] BoundingBox box, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawBoundingBoxNative(box, color);
		}

		[NativeName(NativeNameType.Func, "DrawBillboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawBillboardNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Camera3D, Texture, Vector3, float, Color, void>)vt[464])(camera, texture, position, scale, tint);
			#else
			((delegate* unmanaged[Cdecl]<Camera3D, Texture, Vector3, float, Color, void>)vt[464])(camera, texture, position, scale, tint);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawBillboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawBillboard([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "scale")] [NativeName(NativeNameType.Type, "float")] float scale, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			DrawBillboardNative(camera, texture, position, scale, tint);
		}

		[NativeName(NativeNameType.Func, "DrawBillboardRec")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawBillboardRecNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle source, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 size, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Camera3D, Texture, Rectangle, Vector3, Vector2, Color, void>)vt[465])(camera, texture, source, position, size, tint);
			#else
			((delegate* unmanaged[Cdecl]<Camera3D, Texture, Rectangle, Vector3, Vector2, Color, void>)vt[465])(camera, texture, source, position, size, tint);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawBillboardRec")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawBillboardRec([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle source, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 size, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			DrawBillboardRecNative(camera, texture, source, position, size, tint);
		}

		[NativeName(NativeNameType.Func, "DrawBillboardPro")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawBillboardProNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle source, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "up")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 up, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 size, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 origin, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Camera3D, Texture, Rectangle, Vector3, Vector3, Vector2, Vector2, float, Color, void>)vt[466])(camera, texture, source, position, up, size, origin, rotation, tint);
			#else
			((delegate* unmanaged[Cdecl]<Camera3D, Texture, Rectangle, Vector3, Vector3, Vector2, Vector2, float, Color, void>)vt[466])(camera, texture, source, position, up, size, origin, rotation, tint);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawBillboardPro")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawBillboardPro([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle source, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "up")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 up, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 size, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 origin, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "tint")] [NativeName(NativeNameType.Type, "Color")] Color tint)
		{
			DrawBillboardProNative(camera, texture, source, position, up, size, origin, rotation, tint);
		}

		/// <summary>
		/// Mesh management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "UploadMesh")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void UploadMeshNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh*")] Mesh* mesh, [NativeName(NativeNameType.Param, "dynamic")] [NativeName(NativeNameType.Type, "bool")] byte dynamic)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Mesh*, byte, void>)vt[467])(mesh, dynamic);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)vt[467])((nint)mesh, dynamic);
			#endif
		}

		/// <summary>
		/// Mesh management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "UploadMesh")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh*")] Mesh* mesh, [NativeName(NativeNameType.Param, "dynamic")] [NativeName(NativeNameType.Type, "bool")] bool dynamic)
		{
			UploadMeshNative(mesh, dynamic ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Mesh management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "UploadMesh")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh*")] ref Mesh mesh, [NativeName(NativeNameType.Param, "dynamic")] [NativeName(NativeNameType.Type, "bool")] bool dynamic)
		{
			fixed (Mesh* pmesh = &mesh)
			{
				UploadMeshNative((Mesh*)pmesh, dynamic ? (byte)1 : (byte)0);
			}
		}

		[NativeName(NativeNameType.Func, "UpdateMeshBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void UpdateMeshBufferNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "int")] int offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Mesh, int, void*, int, int, void>)vt[468])(mesh, index, data, dataSize, offset);
			#else
			((delegate* unmanaged[Cdecl]<Mesh, int, nint, int, int, void>)vt[468])(mesh, index, (nint)data, dataSize, offset);
			#endif
		}

		[NativeName(NativeNameType.Func, "UpdateMeshBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateMeshBuffer([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "int")] int offset)
		{
			UpdateMeshBufferNative(mesh, index, data, dataSize, offset);
		}

		[NativeName(NativeNameType.Func, "UnloadMesh")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void UnloadMeshNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Mesh, void>)vt[469])(mesh);
			#else
			((delegate* unmanaged[Cdecl]<Mesh, void>)vt[469])(mesh);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadMesh")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh)
		{
			UnloadMeshNative(mesh);
		}

		[NativeName(NativeNameType.Func, "DrawMesh")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawMeshNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "material")] [NativeName(NativeNameType.Type, "Material")] Material material, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "Matrix")] Matrix4x4 transform)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Mesh, Material, Matrix4x4, void>)vt[470])(mesh, material, transform);
			#else
			((delegate* unmanaged[Cdecl]<Mesh, Material, Matrix4x4, void>)vt[470])(mesh, material, transform);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawMesh")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "material")] [NativeName(NativeNameType.Type, "Material")] Material material, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "Matrix")] Matrix4x4 transform)
		{
			DrawMeshNative(mesh, material, transform);
		}

		[NativeName(NativeNameType.Func, "DrawMeshInstanced")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DrawMeshInstancedNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "material")] [NativeName(NativeNameType.Type, "Material")] Material material, [NativeName(NativeNameType.Param, "transforms")] [NativeName(NativeNameType.Type, "const Matrix*")] Matrix4x4* transforms, [NativeName(NativeNameType.Param, "instances")] [NativeName(NativeNameType.Type, "int")] int instances)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Mesh, Material, Matrix4x4*, int, void>)vt[471])(mesh, material, transforms, instances);
			#else
			((delegate* unmanaged[Cdecl]<Mesh, Material, nint, int, void>)vt[471])(mesh, material, (nint)transforms, instances);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawMeshInstanced")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawMeshInstanced([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "material")] [NativeName(NativeNameType.Type, "Material")] Material material, [NativeName(NativeNameType.Param, "transforms")] [NativeName(NativeNameType.Type, "const Matrix*")] Matrix4x4* transforms, [NativeName(NativeNameType.Param, "instances")] [NativeName(NativeNameType.Type, "int")] int instances)
		{
			DrawMeshInstancedNative(mesh, material, transforms, instances);
		}

		[NativeName(NativeNameType.Func, "DrawMeshInstanced")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawMeshInstanced([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "material")] [NativeName(NativeNameType.Type, "Material")] Material material, [NativeName(NativeNameType.Param, "transforms")] [NativeName(NativeNameType.Type, "const Matrix*")] ref Matrix4x4 transforms, [NativeName(NativeNameType.Param, "instances")] [NativeName(NativeNameType.Type, "int")] int instances)
		{
			fixed (Matrix4x4* ptransforms = &transforms)
			{
				DrawMeshInstancedNative(mesh, material, (Matrix4x4*)ptransforms, instances);
			}
		}

		[NativeName(NativeNameType.Func, "GetMeshBoundingBox")]
		[return: NativeName(NativeNameType.Type, "BoundingBox")]
		internal static BoundingBox GetMeshBoundingBoxNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Mesh, BoundingBox>)vt[472])(mesh);
			#else
			return (BoundingBox)((delegate* unmanaged[Cdecl]<Mesh, BoundingBox>)vt[472])(mesh);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMeshBoundingBox")]
		[return: NativeName(NativeNameType.Type, "BoundingBox")]
		public static BoundingBox GetMeshBoundingBox([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh)
		{
			BoundingBox ret = GetMeshBoundingBoxNative(mesh);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GenMeshTangents")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void GenMeshTangentsNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh*")] Mesh* mesh)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Mesh*, void>)vt[473])(mesh);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[473])((nint)mesh);
			#endif
		}

		[NativeName(NativeNameType.Func, "GenMeshTangents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenMeshTangents([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh*")] Mesh* mesh)
		{
			GenMeshTangentsNative(mesh);
		}

		[NativeName(NativeNameType.Func, "GenMeshTangents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenMeshTangents([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh*")] ref Mesh mesh)
		{
			fixed (Mesh* pmesh = &mesh)
			{
				GenMeshTangentsNative((Mesh*)pmesh);
			}
		}

		[NativeName(NativeNameType.Func, "ExportMesh")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte ExportMeshNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Mesh, byte*, byte>)vt[474])(mesh, fileName);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Mesh, nint, byte>)vt[474])(mesh, (nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "ExportMesh")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] byte* fileName)
		{
			byte ret = ExportMeshNative(mesh, fileName);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "ExportMesh")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = ExportMeshNative(mesh, (byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportMesh")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = ExportMeshNative(mesh, (byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportMesh")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportMesh([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ExportMeshNative(mesh, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "ExportMeshAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte ExportMeshAsCodeNative([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Mesh, byte*, byte>)vt[475])(mesh, fileName);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Mesh, nint, byte>)vt[475])(mesh, (nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "ExportMeshAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportMeshAsCode([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] byte* fileName)
		{
			byte ret = ExportMeshAsCodeNative(mesh, fileName);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "ExportMeshAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportMeshAsCode([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = ExportMeshAsCodeNative(mesh, (byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportMeshAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportMeshAsCode([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = ExportMeshAsCodeNative(mesh, (byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportMeshAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportMeshAsCode([NativeName(NativeNameType.Param, "mesh")] [NativeName(NativeNameType.Type, "Mesh")] Mesh mesh, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "const char*")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ExportMeshAsCodeNative(mesh, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Mesh generation functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "GenMeshPoly")]
		[return: NativeName(NativeNameType.Type, "Mesh")]
		internal static Mesh GenMeshPolyNative([NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, float, Mesh>)vt[476])(sides, radius);
			#else
			return (Mesh)((delegate* unmanaged[Cdecl]<int, float, Mesh>)vt[476])(sides, radius);
			#endif
		}

		/// <summary>
		/// Mesh generation functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "GenMeshPoly")]
		[return: NativeName(NativeNameType.Type, "Mesh")]
		public static Mesh GenMeshPoly([NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			Mesh ret = GenMeshPolyNative(sides, radius);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GenMeshPlane")]
		[return: NativeName(NativeNameType.Type, "Mesh")]
		internal static Mesh GenMeshPlaneNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "resX")] [NativeName(NativeNameType.Type, "int")] int resX, [NativeName(NativeNameType.Param, "resZ")] [NativeName(NativeNameType.Type, "int")] int resZ)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, int, int, Mesh>)vt[477])(width, length, resX, resZ);
			#else
			return (Mesh)((delegate* unmanaged[Cdecl]<float, float, int, int, Mesh>)vt[477])(width, length, resX, resZ);
			#endif
		}

		[NativeName(NativeNameType.Func, "GenMeshPlane")]
		[return: NativeName(NativeNameType.Type, "Mesh")]
		public static Mesh GenMeshPlane([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "resX")] [NativeName(NativeNameType.Type, "int")] int resX, [NativeName(NativeNameType.Param, "resZ")] [NativeName(NativeNameType.Type, "int")] int resZ)
		{
			Mesh ret = GenMeshPlaneNative(width, length, resX, resZ);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GenMeshCube")]
		[return: NativeName(NativeNameType.Type, "Mesh")]
		internal static Mesh GenMeshCubeNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, Mesh>)vt[478])(width, height, length);
			#else
			return (Mesh)((delegate* unmanaged[Cdecl]<float, float, float, Mesh>)vt[478])(width, height, length);
			#endif
		}
	}
}
