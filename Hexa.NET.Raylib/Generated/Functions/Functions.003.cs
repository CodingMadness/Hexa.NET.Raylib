// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Raylib
{
	public unsafe partial class Raylib
	{

		[NativeName(NativeNameType.Func, "GetGlyphIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGlyphIndexNative([NativeName(NativeNameType.Param, "font")] [NativeName(NativeNameType.Type, "Font")] Font font, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Font, int, int>)funcTable[412])(font, codepoint);
			#else
			return (int)((delegate* unmanaged[Cdecl]<Font, int, int>)funcTable[412])(font, codepoint);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGlyphIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGlyphIndex([NativeName(NativeNameType.Param, "font")] [NativeName(NativeNameType.Type, "Font")] Font font, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint)
		{
			int ret = GetGlyphIndexNative(font, codepoint);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGlyphInfo")]
		[return: NativeName(NativeNameType.Type, "GlyphInfo")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GlyphInfo GetGlyphInfoNative([NativeName(NativeNameType.Param, "font")] [NativeName(NativeNameType.Type, "Font")] Font font, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Font, int, GlyphInfo>)funcTable[413])(font, codepoint);
			#else
			return (GlyphInfo)((delegate* unmanaged[Cdecl]<Font, int, GlyphInfo>)funcTable[413])(font, codepoint);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGlyphInfo")]
		[return: NativeName(NativeNameType.Type, "GlyphInfo")]
		public static GlyphInfo GetGlyphInfo([NativeName(NativeNameType.Param, "font")] [NativeName(NativeNameType.Type, "Font")] Font font, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint)
		{
			GlyphInfo ret = GetGlyphInfoNative(font, codepoint);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGlyphAtlasRec")]
		[return: NativeName(NativeNameType.Type, "Rectangle")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Rectangle GetGlyphAtlasRecNative([NativeName(NativeNameType.Param, "font")] [NativeName(NativeNameType.Type, "Font")] Font font, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Font, int, Rectangle>)funcTable[414])(font, codepoint);
			#else
			return (Rectangle)((delegate* unmanaged[Cdecl]<Font, int, Rectangle>)funcTable[414])(font, codepoint);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGlyphAtlasRec")]
		[return: NativeName(NativeNameType.Type, "Rectangle")]
		public static Rectangle GetGlyphAtlasRec([NativeName(NativeNameType.Param, "font")] [NativeName(NativeNameType.Type, "Font")] Font font, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint)
		{
			Rectangle ret = GetGlyphAtlasRecNative(font, codepoint);
			return ret;
		}

		/// <summary>
		/// Text codepoints management functions (unicode characters)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadUTF8")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* LoadUTF8Native([NativeName(NativeNameType.Param, "codepoints")] [NativeName(NativeNameType.Type, "int const *")] int* codepoints, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, byte*>)funcTable[415])(codepoints, length);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[415])((nint)codepoints, length);
			#endif
		}

		/// <summary>
		/// Text codepoints management functions (unicode characters)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadUTF8")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* LoadUTF8([NativeName(NativeNameType.Param, "codepoints")] [NativeName(NativeNameType.Type, "int const *")] int* codepoints, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* ret = LoadUTF8Native(codepoints, length);
			return ret;
		}

		/// <summary>
		/// Text codepoints management functions (unicode characters)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadUTF8")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LoadUTF8S([NativeName(NativeNameType.Param, "codepoints")] [NativeName(NativeNameType.Type, "int const *")] int* codepoints, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			string ret = Utils.DecodeStringUTF8(LoadUTF8Native(codepoints, length));
			return ret;
		}

		/// <summary>
		/// Text codepoints management functions (unicode characters)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadUTF8")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* LoadUTF8([NativeName(NativeNameType.Param, "codepoints")] [NativeName(NativeNameType.Type, "int const *")] ref int codepoints, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (int* pcodepoints = &codepoints)
			{
				byte* ret = LoadUTF8Native((int*)pcodepoints, length);
				return ret;
			}
		}

		/// <summary>
		/// Text codepoints management functions (unicode characters)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadUTF8")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LoadUTF8S([NativeName(NativeNameType.Param, "codepoints")] [NativeName(NativeNameType.Type, "int const *")] ref int codepoints, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (int* pcodepoints = &codepoints)
			{
				string ret = Utils.DecodeStringUTF8(LoadUTF8Native((int*)pcodepoints, length));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "UnloadUTF8")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadUTF8Native([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[416])(text);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[416])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadUTF8")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadUTF8([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			UnloadUTF8Native(text);
		}

		[NativeName(NativeNameType.Func, "UnloadUTF8")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadUTF8([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				UnloadUTF8Native((byte*)ptext);
			}
		}

		[NativeName(NativeNameType.Func, "UnloadUTF8")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadUTF8([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			UnloadUTF8Native(pStr0);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* LoadCodepointsNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, int*>)funcTable[417])(text, count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[417])((nint)text, (nint)count);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadCodepoints([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			int* ret = LoadCodepointsNative(text, count);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadCodepoints([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ptext = &text)
			{
				int* ret = LoadCodepointsNative((byte*)ptext, count);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadCodepoints([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ptext = text)
			{
				int* ret = LoadCodepointsNative((byte*)ptext, count);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadCodepoints([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int* ret = LoadCodepointsNative(pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadCodepoints([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = LoadCodepointsNative(text, (int*)pcount);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadCodepoints([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ptext = &text)
			{
				fixed (int* pcount = &count)
				{
					int* ret = LoadCodepointsNative((byte*)ptext, (int*)pcount);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadCodepoints([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ptext = text)
			{
				fixed (int* pcount = &count)
				{
					int* ret = LoadCodepointsNative((byte*)ptext, (int*)pcount);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadCodepoints")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadCodepoints([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcount = &count)
			{
				int* ret = LoadCodepointsNative(pStr0, (int*)pcount);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "UnloadCodepoints")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadCodepointsNative([NativeName(NativeNameType.Param, "codepoints")] [NativeName(NativeNameType.Type, "int *")] int* codepoints)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[418])(codepoints);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[418])((nint)codepoints);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadCodepoints")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadCodepoints([NativeName(NativeNameType.Param, "codepoints")] [NativeName(NativeNameType.Type, "int *")] int* codepoints)
		{
			UnloadCodepointsNative(codepoints);
		}

		[NativeName(NativeNameType.Func, "UnloadCodepoints")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadCodepoints([NativeName(NativeNameType.Param, "codepoints")] [NativeName(NativeNameType.Type, "int *")] ref int codepoints)
		{
			fixed (int* pcodepoints = &codepoints)
			{
				UnloadCodepointsNative((int*)pcodepoints);
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCodepointCountNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[419])(text);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[419])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCodepointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointCount([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			int ret = GetCodepointCountNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointCount([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = GetCodepointCountNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointCount([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				int ret = GetCodepointCountNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointCount([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetCodepointCountNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCodepointNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, int>)funcTable[420])(text, codepointSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[420])((nint)text, (nint)codepointSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepoint([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			int ret = GetCodepointNative(text, codepointSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepoint([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			fixed (byte* ptext = &text)
			{
				int ret = GetCodepointNative((byte*)ptext, codepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepoint([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			fixed (byte* ptext = text)
			{
				int ret = GetCodepointNative((byte*)ptext, codepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepoint([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetCodepointNative(pStr0, codepointSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepoint([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (int* pcodepointSize = &codepointSize)
			{
				int ret = GetCodepointNative(text, (int*)pcodepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepoint([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (byte* ptext = &text)
			{
				fixed (int* pcodepointSize = &codepointSize)
				{
					int ret = GetCodepointNative((byte*)ptext, (int*)pcodepointSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepoint([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (byte* ptext = text)
			{
				fixed (int* pcodepointSize = &codepointSize)
				{
					int ret = GetCodepointNative((byte*)ptext, (int*)pcodepointSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepoint([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcodepointSize = &codepointSize)
			{
				int ret = GetCodepointNative(pStr0, (int*)pcodepointSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCodepointNextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, int>)funcTable[421])(text, codepointSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[421])((nint)text, (nint)codepointSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointNext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			int ret = GetCodepointNextNative(text, codepointSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointNext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			fixed (byte* ptext = &text)
			{
				int ret = GetCodepointNextNative((byte*)ptext, codepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointNext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			fixed (byte* ptext = text)
			{
				int ret = GetCodepointNextNative((byte*)ptext, codepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointNext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetCodepointNextNative(pStr0, codepointSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointNext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (int* pcodepointSize = &codepointSize)
			{
				int ret = GetCodepointNextNative(text, (int*)pcodepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointNext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (byte* ptext = &text)
			{
				fixed (int* pcodepointSize = &codepointSize)
				{
					int ret = GetCodepointNextNative((byte*)ptext, (int*)pcodepointSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointNext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (byte* ptext = text)
			{
				fixed (int* pcodepointSize = &codepointSize)
				{
					int ret = GetCodepointNextNative((byte*)ptext, (int*)pcodepointSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointNext")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointNext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcodepointSize = &codepointSize)
			{
				int ret = GetCodepointNextNative(pStr0, (int*)pcodepointSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCodepointPreviousNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, int>)funcTable[422])(text, codepointSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[422])((nint)text, (nint)codepointSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			int ret = GetCodepointPreviousNative(text, codepointSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			fixed (byte* ptext = &text)
			{
				int ret = GetCodepointPreviousNative((byte*)ptext, codepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			fixed (byte* ptext = text)
			{
				int ret = GetCodepointPreviousNative((byte*)ptext, codepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] int* codepointSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetCodepointPreviousNative(pStr0, codepointSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (int* pcodepointSize = &codepointSize)
			{
				int ret = GetCodepointPreviousNative(text, (int*)pcodepointSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (byte* ptext = &text)
			{
				fixed (int* pcodepointSize = &codepointSize)
				{
					int ret = GetCodepointPreviousNative((byte*)ptext, (int*)pcodepointSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			fixed (byte* ptext = text)
			{
				fixed (int* pcodepointSize = &codepointSize)
				{
					int ret = GetCodepointPreviousNative((byte*)ptext, (int*)pcodepointSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "GetCodepointPrevious")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCodepointPrevious([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "codepointSize")] [NativeName(NativeNameType.Type, "int *")] ref int codepointSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcodepointSize = &codepointSize)
			{
				int ret = GetCodepointPreviousNative(pStr0, (int*)pcodepointSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CodepointToUTF8Native([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int *")] int* utf8Size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int*, byte*>)funcTable[423])(codepoint, utf8Size);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint, nint>)funcTable[423])(codepoint, (nint)utf8Size);
			#endif
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* CodepointToUTF8([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int *")] int* utf8Size)
		{
			byte* ret = CodepointToUTF8Native(codepoint, utf8Size);
			return ret;
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string CodepointToUTF8S([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int *")] int* utf8Size)
		{
			string ret = Utils.DecodeStringUTF8(CodepointToUTF8Native(codepoint, utf8Size));
			return ret;
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* CodepointToUTF8([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int *")] ref int utf8Size)
		{
			fixed (int* putf8Size = &utf8Size)
			{
				byte* ret = CodepointToUTF8Native(codepoint, (int*)putf8Size);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "CodepointToUTF8")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string CodepointToUTF8S([NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "int")] int codepoint, [NativeName(NativeNameType.Param, "utf8Size")] [NativeName(NativeNameType.Type, "int *")] ref int utf8Size)
		{
			fixed (int* putf8Size = &utf8Size)
			{
				string ret = Utils.DecodeStringUTF8(CodepointToUTF8Native(codepoint, (int*)putf8Size));
				return ret;
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TextCopyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[424])(dst, src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[424])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src)
		{
			int ret = TextCopyNative(dst, src);
			return ret;
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src)
		{
			fixed (byte* pdst = &dst)
			{
				int ret = TextCopyNative((byte*)pdst, src);
				return ret;
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] byte* src)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextCopyNative(pStr0, src);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ref byte src)
		{
			fixed (byte* psrc = &src)
			{
				int ret = TextCopyNative(dst, (byte*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> src)
		{
			fixed (byte* psrc = src)
			{
				int ret = TextCopyNative(dst, (byte*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] string src)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextCopyNative(dst, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ref byte src)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					int ret = TextCopyNative((byte*)pdst, (byte*)psrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> src)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					int ret = TextCopyNative((byte*)pdst, (byte*)psrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Text strings management functions (no UTF-8 strings, only byte chars)<br/>
		/// WARNING 1: Most of these functions use internal static buffers, it's recommended to store returned data on user-side for re-use<br/>
		/// WARNING 2: Some strings allocate memory internally for the returned strings, those strings must be free by user using MemFree()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TextCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextCopy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char *")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "char const *")] string src)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = TextCopyNative(pStr0, pStr1);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TextIsEqualNative([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] byte* text2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)funcTable[425])(text1, text2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[425])((nint)text1, (nint)text2);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] byte* text2)
		{
			byte ret = TextIsEqualNative(text1, text2);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] ref byte text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] byte* text2)
		{
			fixed (byte* ptext1 = &text1)
			{
				byte ret = TextIsEqualNative((byte*)ptext1, text2);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] byte* text2)
		{
			fixed (byte* ptext1 = text1)
			{
				byte ret = TextIsEqualNative((byte*)ptext1, text2);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] string text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] byte* text2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TextIsEqualNative(pStr0, text2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] ref byte text2)
		{
			fixed (byte* ptext2 = &text2)
			{
				byte ret = TextIsEqualNative(text1, (byte*)ptext2);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text2)
		{
			fixed (byte* ptext2 = text2)
			{
				byte ret = TextIsEqualNative(text1, (byte*)ptext2);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] byte* text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] string text2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TextIsEqualNative(text1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] ref byte text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] ref byte text2)
		{
			fixed (byte* ptext1 = &text1)
			{
				fixed (byte* ptext2 = &text2)
				{
					byte ret = TextIsEqualNative((byte*)ptext1, (byte*)ptext2);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text2)
		{
			fixed (byte* ptext1 = text1)
			{
				fixed (byte* ptext2 = text2)
				{
					byte ret = TextIsEqualNative((byte*)ptext1, (byte*)ptext2);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextIsEqual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TextIsEqual([NativeName(NativeNameType.Param, "text1")] [NativeName(NativeNameType.Type, "char const *")] string text1, [NativeName(NativeNameType.Param, "text2")] [NativeName(NativeNameType.Type, "char const *")] string text2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (text2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(text2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(text2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TextIsEqualNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TextLengthNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint>)funcTable[426])(text);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[426])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint TextLength([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			uint ret = TextLengthNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint TextLength([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				uint ret = TextLengthNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint TextLength([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				uint ret = TextLengthNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextLength")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint TextLength([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = TextLengthNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextFormatNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[427])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[427])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextFormat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			byte* ret = TextFormatNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextFormatS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextFormatNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextFormat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextFormatNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextFormatS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextFormatNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextFormat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextFormatNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextFormatS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextFormatNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextFormat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextFormatNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFormat")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextFormatS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextFormatNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextSubtextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int, byte*>)funcTable[428])(text, position, length);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)funcTable[428])((nint)text, position, length);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextSubtext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* ret = TextSubtextNative(text, position, length);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextSubtextS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			string ret = Utils.DecodeStringUTF8(TextSubtextNative(text, position, length));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextSubtext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextSubtextNative((byte*)ptext, position, length);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextSubtextS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextSubtextNative((byte*)ptext, position, length));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextSubtext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextSubtextNative((byte*)ptext, position, length);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextSubtextS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextSubtextNative((byte*)ptext, position, length));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextSubtext([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextSubtextNative(pStr0, position, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextSubtext")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextSubtextS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextSubtextNative(pStr0, position, length));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextReplaceNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, byte*>)funcTable[429])(text, replace, by);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint>)funcTable[429])((nint)text, (nint)replace, (nint)by);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			byte* ret = TextReplaceNative(text, replace, by);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, replace, by));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextReplaceNative((byte*)ptext, replace, by);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, replace, by));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextReplaceNative((byte*)ptext, replace, by);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, replace, by));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextReplaceNative(pStr0, replace, by);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(pStr0, replace, by));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* preplace = &replace)
			{
				byte* ret = TextReplaceNative(text, (byte*)preplace, by);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* preplace = &replace)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, (byte*)preplace, by));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* preplace = replace)
			{
				byte* ret = TextReplaceNative(text, (byte*)preplace, by);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* preplace = replace)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, (byte*)preplace, by));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (replace != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(replace);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(replace, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextReplaceNative(text, pStr0, by);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (replace != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(replace);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(replace, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, pStr0, by));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* preplace = &replace)
				{
					byte* ret = TextReplaceNative((byte*)ptext, (byte*)preplace, by);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* preplace = &replace)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, (byte*)preplace, by));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* preplace = replace)
				{
					byte* ret = TextReplaceNative((byte*)ptext, (byte*)preplace, by);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* preplace = replace)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, (byte*)preplace, by));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (replace != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(replace);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(replace, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = TextReplaceNative(pStr0, pStr1, by);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] byte* by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (replace != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(replace);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(replace, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(pStr0, pStr1, by));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ref byte by)
		{
			fixed (byte* pby = &by)
			{
				byte* ret = TextReplaceNative(text, replace, (byte*)pby);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ref byte by)
		{
			fixed (byte* pby = &by)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, replace, (byte*)pby));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> by)
		{
			fixed (byte* pby = by)
			{
				byte* ret = TextReplaceNative(text, replace, (byte*)pby);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> by)
		{
			fixed (byte* pby = by)
			{
				string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, replace, (byte*)pby));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (by != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(by);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(by, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextReplaceNative(text, replace, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (by != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(by);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(by, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, replace, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ref byte by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pby = &by)
				{
					byte* ret = TextReplaceNative((byte*)ptext, replace, (byte*)pby);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ref byte by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pby = &by)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, replace, (byte*)pby));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pby = by)
				{
					byte* ret = TextReplaceNative((byte*)ptext, replace, (byte*)pby);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pby = by)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, replace, (byte*)pby));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (by != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(by);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(by, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = TextReplaceNative(pStr0, replace, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] byte* replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (by != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(by);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(by, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(pStr0, replace, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ref byte by)
		{
			fixed (byte* preplace = &replace)
			{
				fixed (byte* pby = &by)
				{
					byte* ret = TextReplaceNative(text, (byte*)preplace, (byte*)pby);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ref byte by)
		{
			fixed (byte* preplace = &replace)
			{
				fixed (byte* pby = &by)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, (byte*)preplace, (byte*)pby));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> by)
		{
			fixed (byte* preplace = replace)
			{
				fixed (byte* pby = by)
				{
					byte* ret = TextReplaceNative(text, (byte*)preplace, (byte*)pby);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> by)
		{
			fixed (byte* preplace = replace)
			{
				fixed (byte* pby = by)
				{
					string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, (byte*)preplace, (byte*)pby));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (replace != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(replace);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(replace, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (by != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(by);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(by, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = TextReplaceNative(text, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (replace != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(replace);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(replace, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (by != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(by);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(by, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(text, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ref byte by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* preplace = &replace)
				{
					fixed (byte* pby = &by)
					{
						byte* ret = TextReplaceNative((byte*)ptext, (byte*)preplace, (byte*)pby);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ref byte replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ref byte by)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* preplace = &replace)
				{
					fixed (byte* pby = &by)
					{
						string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, (byte*)preplace, (byte*)pby));
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* preplace = replace)
				{
					fixed (byte* pby = by)
					{
						byte* ret = TextReplaceNative((byte*)ptext, (byte*)preplace, (byte*)pby);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> by)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* preplace = replace)
				{
					fixed (byte* pby = by)
					{
						string ret = Utils.DecodeStringUTF8(TextReplaceNative((byte*)ptext, (byte*)preplace, (byte*)pby));
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextReplace([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (replace != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(replace);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(replace, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (by != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(by);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(by, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = TextReplaceNative(pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextReplace")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextReplaceS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "replace")] [NativeName(NativeNameType.Type, "char const *")] string replace, [NativeName(NativeNameType.Param, "by")] [NativeName(NativeNameType.Type, "char const *")] string by)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (replace != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(replace);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(replace, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (by != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(by);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(by, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextReplaceNative(pStr0, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextInsertNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, byte*>)funcTable[430])(text, insert, position);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)funcTable[430])((nint)text, (nint)insert, position);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* ret = TextInsertNative(text, insert, position);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			string ret = Utils.DecodeStringUTF8(TextInsertNative(text, insert, position));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextInsertNative((byte*)ptext, insert, position);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextInsertNative((byte*)ptext, insert, position));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextInsertNative((byte*)ptext, insert, position);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextInsertNative((byte*)ptext, insert, position));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextInsertNative(pStr0, insert, position);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] byte* insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextInsertNative(pStr0, insert, position));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] ref byte insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* pinsert = &insert)
			{
				byte* ret = TextInsertNative(text, (byte*)pinsert, position);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] ref byte insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* pinsert = &insert)
			{
				string ret = Utils.DecodeStringUTF8(TextInsertNative(text, (byte*)pinsert, position));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* pinsert = insert)
			{
				byte* ret = TextInsertNative(text, (byte*)pinsert, position);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* pinsert = insert)
			{
				string ret = Utils.DecodeStringUTF8(TextInsertNative(text, (byte*)pinsert, position));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] string insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (insert != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(insert);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(insert, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextInsertNative(text, pStr0, position);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] string insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (insert != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(insert);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(insert, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextInsertNative(text, pStr0, position));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] ref byte insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pinsert = &insert)
				{
					byte* ret = TextInsertNative((byte*)ptext, (byte*)pinsert, position);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] ref byte insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pinsert = &insert)
				{
					string ret = Utils.DecodeStringUTF8(TextInsertNative((byte*)ptext, (byte*)pinsert, position));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pinsert = insert)
				{
					byte* ret = TextInsertNative((byte*)ptext, (byte*)pinsert, position);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pinsert = insert)
				{
					string ret = Utils.DecodeStringUTF8(TextInsertNative((byte*)ptext, (byte*)pinsert, position));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextInsert([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] string insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (insert != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(insert);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(insert, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = TextInsertNative(pStr0, pStr1, position);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextInsert")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextInsertS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "insert")] [NativeName(NativeNameType.Type, "char const *")] string insert, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int")] int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (insert != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(insert);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(insert, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextInsertNative(pStr0, pStr1, position));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextJoinNative([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] byte* delimiter)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, int, byte*, byte*>)funcTable[431])(textList, count, delimiter);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)funcTable[431])((nint)textList, count, (nint)delimiter);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] byte* delimiter)
		{
			byte* ret = TextJoinNative(textList, count, delimiter);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] byte* delimiter)
		{
			string ret = Utils.DecodeStringUTF8(TextJoinNative(textList, count, delimiter));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] byte* delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				byte* ret = TextJoinNative((byte**)ptextList, count, delimiter);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] byte* delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				string ret = Utils.DecodeStringUTF8(TextJoinNative((byte**)ptextList, count, delimiter));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] ref byte delimiter)
		{
			fixed (byte* pdelimiter = &delimiter)
			{
				byte* ret = TextJoinNative(textList, count, (byte*)pdelimiter);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] ref byte delimiter)
		{
			fixed (byte* pdelimiter = &delimiter)
			{
				string ret = Utils.DecodeStringUTF8(TextJoinNative(textList, count, (byte*)pdelimiter));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> delimiter)
		{
			fixed (byte* pdelimiter = delimiter)
			{
				byte* ret = TextJoinNative(textList, count, (byte*)pdelimiter);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> delimiter)
		{
			fixed (byte* pdelimiter = delimiter)
			{
				string ret = Utils.DecodeStringUTF8(TextJoinNative(textList, count, (byte*)pdelimiter));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] string delimiter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (delimiter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(delimiter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(delimiter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextJoinNative(textList, count, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] byte** textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] string delimiter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (delimiter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(delimiter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(delimiter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextJoinNative(textList, count, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] ref byte delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				fixed (byte* pdelimiter = &delimiter)
				{
					byte* ret = TextJoinNative((byte**)ptextList, count, (byte*)pdelimiter);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] ref byte delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				fixed (byte* pdelimiter = &delimiter)
				{
					string ret = Utils.DecodeStringUTF8(TextJoinNative((byte**)ptextList, count, (byte*)pdelimiter));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				fixed (byte* pdelimiter = delimiter)
				{
					byte* ret = TextJoinNative((byte**)ptextList, count, (byte*)pdelimiter);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				fixed (byte* pdelimiter = delimiter)
				{
					string ret = Utils.DecodeStringUTF8(TextJoinNative((byte**)ptextList, count, (byte*)pdelimiter));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextJoin([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] string delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (delimiter != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(delimiter);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(delimiter, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = TextJoinNative((byte**)ptextList, count, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextJoin")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextJoinS([NativeName(NativeNameType.Param, "textList")] [NativeName(NativeNameType.Type, "char * *")] ref byte* textList, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "delimiter")] [NativeName(NativeNameType.Type, "char const *")] string delimiter)
		{
			fixed (byte** ptextList = &textList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (delimiter != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(delimiter);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(delimiter, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(TextJoinNative((byte**)ptextList, count, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextAppendNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, int*, void>)funcTable[432])(text, append, position);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[432])((nint)text, (nint)append, (nint)position);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			TextAppendNative(text, append, position);
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			fixed (byte* ptext = &text)
			{
				TextAppendNative((byte*)ptext, append, position);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref string text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextAppendNative(pStr0, append, position);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] ref byte append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			fixed (byte* pappend = &append)
			{
				TextAppendNative(text, (byte*)pappend, position);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			fixed (byte* pappend = append)
			{
				TextAppendNative(text, (byte*)pappend, position);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] string append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (append != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(append);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(append, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextAppendNative(text, pStr0, position);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] ref byte append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pappend = &append)
				{
					TextAppendNative((byte*)ptext, (byte*)pappend, position);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pappend = append)
				{
					TextAppendNative((byte*)ptext, (byte*)pappend, position);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref string text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] string append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] int* position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (append != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(append);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(append, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			TextAppendNative(pStr0, pStr1, position);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			fixed (int* pposition = &position)
			{
				TextAppendNative(text, append, (int*)pposition);
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (int* pposition = &position)
				{
					TextAppendNative((byte*)ptext, append, (int*)pposition);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref string text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] byte* append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pposition = &position)
			{
				TextAppendNative(pStr0, append, (int*)pposition);
				text = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] ref byte append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			fixed (byte* pappend = &append)
			{
				fixed (int* pposition = &position)
				{
					TextAppendNative(text, (byte*)pappend, (int*)pposition);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			fixed (byte* pappend = append)
			{
				fixed (int* pposition = &position)
				{
					TextAppendNative(text, (byte*)pappend, (int*)pposition);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] string append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (append != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(append);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(append, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pposition = &position)
			{
				TextAppendNative(text, pStr0, (int*)pposition);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] ref byte append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pappend = &append)
				{
					fixed (int* pposition = &position)
					{
						TextAppendNative((byte*)ptext, (byte*)pappend, (int*)pposition);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pappend = append)
				{
					fixed (int* pposition = &position)
					{
						TextAppendNative((byte*)ptext, (byte*)pappend, (int*)pposition);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextAppend")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TextAppend([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref string text, [NativeName(NativeNameType.Param, "append")] [NativeName(NativeNameType.Type, "char const *")] string append, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "int *")] ref int position)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (append != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(append);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(append, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (int* pposition = &position)
			{
				TextAppendNative(pStr0, pStr1, (int*)pposition);
				text = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TextFindIndexNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] byte* find)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[433])(text, find);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[433])((nint)text, (nint)find);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] byte* find)
		{
			int ret = TextFindIndexNative(text, find);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] byte* find)
		{
			fixed (byte* ptext = &text)
			{
				int ret = TextFindIndexNative((byte*)ptext, find);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] byte* find)
		{
			fixed (byte* ptext = text)
			{
				int ret = TextFindIndexNative((byte*)ptext, find);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] byte* find)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextFindIndexNative(pStr0, find);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] ref byte find)
		{
			fixed (byte* pfind = &find)
			{
				int ret = TextFindIndexNative(text, (byte*)pfind);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> find)
		{
			fixed (byte* pfind = find)
			{
				int ret = TextFindIndexNative(text, (byte*)pfind);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] string find)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (find != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(find);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(find, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextFindIndexNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] ref byte find)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfind = &find)
				{
					int ret = TextFindIndexNative((byte*)ptext, (byte*)pfind);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> find)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* pfind = find)
				{
					int ret = TextFindIndexNative((byte*)ptext, (byte*)pfind);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "TextFindIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextFindIndex([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "find")] [NativeName(NativeNameType.Type, "char const *")] string find)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (find != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(find);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(find, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = TextFindIndexNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextToUpperNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[434])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[434])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToUpper([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			byte* ret = TextToUpperNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToUpperS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToUpperNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToUpper([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToUpperNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToUpperS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToUpperNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToUpper([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToUpperNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToUpperS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToUpperNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToUpper([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToUpperNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToUpper")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToUpperS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToUpperNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextToLowerNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[435])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[435])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToLower([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			byte* ret = TextToLowerNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToLowerS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToLowerNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToLower([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToLowerNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToLowerS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToLowerNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToLower([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToLowerNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToLowerS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToLowerNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToLower([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToLowerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToLower")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToLowerS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToLowerNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextToPascalNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[436])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[436])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToPascal([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			byte* ret = TextToPascalNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToPascalS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToPascalNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToPascal([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToPascalNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToPascalS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToPascalNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToPascal([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToPascalNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToPascalS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToPascalNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToPascal([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToPascalNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToPascal")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToPascalS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToPascalNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextToSnakeNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[437])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[437])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToSnake([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			byte* ret = TextToSnakeNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToSnakeS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToSnakeNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToSnake([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToSnakeNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToSnakeS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToSnakeNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToSnake([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToSnakeNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToSnakeS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToSnakeNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToSnake([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToSnakeNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToSnake")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToSnakeS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToSnakeNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextToCamelNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[438])(text);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[438])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToCamel([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			byte* ret = TextToCamelNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToCamelS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			string ret = Utils.DecodeStringUTF8(TextToCamelNative(text));
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToCamel([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = TextToCamelNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToCamelS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(TextToCamelNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToCamel([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte* ret = TextToCamelNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToCamelS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				string ret = Utils.DecodeStringUTF8(TextToCamelNative((byte*)ptext));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TextToCamel([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TextToCamelNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToCamel")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TextToCamelS([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TextToCamelNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TextToIntegerNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[439])(text);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[439])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextToInteger([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			int ret = TextToIntegerNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextToInteger([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = TextToIntegerNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextToInteger([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				int ret = TextToIntegerNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToInteger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TextToInteger([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TextToIntegerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TextToFloatNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, float>)funcTable[440])(text);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[440])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TextToFloat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			float ret = TextToFloatNative(text);
			return ret;
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TextToFloat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				float ret = TextToFloatNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TextToFloat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				float ret = TextToFloatNative((byte*)ptext);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "TextToFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TextToFloat([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			float ret = TextToFloatNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Basic geometric 3D shapes drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawLine3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawLine3DNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)funcTable[441])(startPos, endPos, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)funcTable[441])(startPos, endPos, color);
			#endif
		}

		/// <summary>
		/// Basic geometric 3D shapes drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawLine3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawLine3D([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawLine3DNative(startPos, endPos, color);
		}

		[NativeName(NativeNameType.Func, "DrawPoint3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawPoint3DNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Color, void>)funcTable[442])(position, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Color, void>)funcTable[442])(position, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawPoint3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawPoint3D([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawPoint3DNative(position, color);
		}

		[NativeName(NativeNameType.Func, "DrawCircle3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCircle3DNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotationAxis")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotationAxis, [NativeName(NativeNameType.Param, "rotationAngle")] [NativeName(NativeNameType.Type, "float")] float rotationAngle, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, Vector3, float, Color, void>)funcTable[443])(center, radius, rotationAxis, rotationAngle, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, Vector3, float, Color, void>)funcTable[443])(center, radius, rotationAxis, rotationAngle, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircle3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircle3D([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotationAxis")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotationAxis, [NativeName(NativeNameType.Param, "rotationAngle")] [NativeName(NativeNameType.Type, "float")] float rotationAngle, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCircle3DNative(center, radius, rotationAxis, rotationAngle, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangle3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTriangle3DNative([NativeName(NativeNameType.Param, "v1")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v1, [NativeName(NativeNameType.Param, "v2")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v2, [NativeName(NativeNameType.Param, "v3")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v3, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Vector3, Color, void>)funcTable[444])(v1, v2, v3, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Vector3, Color, void>)funcTable[444])(v1, v2, v3, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawTriangle3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangle3D([NativeName(NativeNameType.Param, "v1")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v1, [NativeName(NativeNameType.Param, "v2")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v2, [NativeName(NativeNameType.Param, "v3")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 v3, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawTriangle3DNative(v1, v2, v3, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTriangleStrip3DNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector3 const *")] Vector3* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, int, Color, void>)funcTable[445])(points, pointCount, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, Color, void>)funcTable[445])((nint)points, pointCount, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleStrip3D([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector3 const *")] Vector3* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawTriangleStrip3DNative(points, pointCount, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleStrip3D([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector3 const *")] ref Vector3 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector3* ppoints = &points)
			{
				DrawTriangleStrip3DNative((Vector3*)ppoints, pointCount, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawCube")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCubeNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, Color, void>)funcTable[446])(position, width, height, length, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, Color, void>)funcTable[446])(position, width, height, length, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCube")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCube([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCubeNative(position, width, height, length, color);
		}

		[NativeName(NativeNameType.Func, "DrawCubeV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCubeVNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)funcTable[447])(position, size, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)funcTable[447])(position, size, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCubeV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCubeV([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCubeVNative(position, size, color);
		}

		[NativeName(NativeNameType.Func, "DrawCubeWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCubeWiresNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, Color, void>)funcTable[448])(position, width, height, length, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, Color, void>)funcTable[448])(position, width, height, length, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCubeWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCubeWires([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "float")] float width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCubeWiresNative(position, width, height, length, color);
		}

		[NativeName(NativeNameType.Func, "DrawCubeWiresV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCubeWiresVNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)funcTable[449])(position, size, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, Color, void>)funcTable[449])(position, size, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCubeWiresV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCubeWiresV([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCubeWiresVNative(position, size, color);
		}

		[NativeName(NativeNameType.Func, "DrawSphere")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSphereNative([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, Color, void>)funcTable[450])(centerPos, radius, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, Color, void>)funcTable[450])(centerPos, radius, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSphere")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSphere([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSphereNative(centerPos, radius, color);
		}

		[NativeName(NativeNameType.Func, "DrawSphereEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSphereExNative([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, int, int, Color, void>)funcTable[451])(centerPos, radius, rings, slices, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, int, int, Color, void>)funcTable[451])(centerPos, radius, rings, slices, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSphereEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSphereEx([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSphereExNative(centerPos, radius, rings, slices, color);
		}

		[NativeName(NativeNameType.Func, "DrawSphereWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSphereWiresNative([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, int, int, Color, void>)funcTable[452])(centerPos, radius, rings, slices, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, int, int, Color, void>)funcTable[452])(centerPos, radius, rings, slices, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSphereWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSphereWires([NativeName(NativeNameType.Param, "centerPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 centerPos, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rings")] [NativeName(NativeNameType.Type, "int")] int rings, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSphereWiresNative(centerPos, radius, rings, slices, color);
		}

		[NativeName(NativeNameType.Func, "DrawCylinder")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCylinderNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "radiusTop")] [NativeName(NativeNameType.Type, "float")] float radiusTop, [NativeName(NativeNameType.Param, "radiusBottom")] [NativeName(NativeNameType.Type, "float")] float radiusBottom, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, int, Color, void>)funcTable[453])(position, radiusTop, radiusBottom, height, slices, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, int, Color, void>)funcTable[453])(position, radiusTop, radiusBottom, height, slices, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCylinder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCylinder([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "radiusTop")] [NativeName(NativeNameType.Type, "float")] float radiusTop, [NativeName(NativeNameType.Param, "radiusBottom")] [NativeName(NativeNameType.Type, "float")] float radiusBottom, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCylinderNative(position, radiusTop, radiusBottom, height, slices, color);
		}

		[NativeName(NativeNameType.Func, "DrawCylinderEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCylinderExNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "startRadius")] [NativeName(NativeNameType.Type, "float")] float startRadius, [NativeName(NativeNameType.Param, "endRadius")] [NativeName(NativeNameType.Type, "float")] float endRadius, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, float, int, Color, void>)funcTable[454])(startPos, endPos, startRadius, endRadius, sides, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, Vector3, float, float, int, Color, void>)funcTable[454])(startPos, endPos, startRadius, endRadius, sides, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCylinderEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCylinderEx([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 endPos, [NativeName(NativeNameType.Param, "startRadius")] [NativeName(NativeNameType.Type, "float")] float startRadius, [NativeName(NativeNameType.Param, "endRadius")] [NativeName(NativeNameType.Type, "float")] float endRadius, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCylinderExNative(startPos, endPos, startRadius, endRadius, sides, color);
		}

		[NativeName(NativeNameType.Func, "DrawCylinderWires")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCylinderWiresNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "radiusTop")] [NativeName(NativeNameType.Type, "float")] float radiusTop, [NativeName(NativeNameType.Param, "radiusBottom")] [NativeName(NativeNameType.Type, "float")] float radiusBottom, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "float")] float height, [NativeName(NativeNameType.Param, "slices")] [NativeName(NativeNameType.Type, "int")] int slices, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, int, Color, void>)funcTable[455])(position, radiusTop, radiusBottom, height, slices, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector3, float, float, float, int, Color, void>)funcTable[455])(position, radiusTop, radiusBottom, height, slices, color);
			#endif
		}
	}
}
