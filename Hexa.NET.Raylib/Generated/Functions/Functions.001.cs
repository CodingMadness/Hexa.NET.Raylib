// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Raylib
{
	public unsafe partial class Raylib
	{

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetDirectoryPathS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filePath)
		{
			fixed (byte* pfilePath = filePath)
			{
				string ret = Utils.DecodeStringUTF8(GetDirectoryPathNative((byte*)pfilePath));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetDirectoryPath([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] string filePath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filePath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filePath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filePath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetDirectoryPathNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetDirectoryPathS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] string filePath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filePath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filePath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filePath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetDirectoryPathNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetPrevDirectoryPathNative([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[131])(dirPath);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[131])((nint)dirPath);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetPrevDirectoryPath([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			byte* ret = GetPrevDirectoryPathNative(dirPath);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetPrevDirectoryPathS([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			string ret = Utils.DecodeStringUTF8(GetPrevDirectoryPathNative(dirPath));
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetPrevDirectoryPath([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ref byte dirPath)
		{
			fixed (byte* pdirPath = &dirPath)
			{
				byte* ret = GetPrevDirectoryPathNative((byte*)pdirPath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetPrevDirectoryPathS([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ref byte dirPath)
		{
			fixed (byte* pdirPath = &dirPath)
			{
				string ret = Utils.DecodeStringUTF8(GetPrevDirectoryPathNative((byte*)pdirPath));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetPrevDirectoryPath([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> dirPath)
		{
			fixed (byte* pdirPath = dirPath)
			{
				byte* ret = GetPrevDirectoryPathNative((byte*)pdirPath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetPrevDirectoryPathS([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> dirPath)
		{
			fixed (byte* pdirPath = dirPath)
			{
				string ret = Utils.DecodeStringUTF8(GetPrevDirectoryPathNative((byte*)pdirPath));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetPrevDirectoryPath([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] string dirPath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dirPath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dirPath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dirPath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetPrevDirectoryPathNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetPrevDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetPrevDirectoryPathS([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] string dirPath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dirPath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dirPath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dirPath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetPrevDirectoryPathNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetWorkingDirectory")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetWorkingDirectoryNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[132])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[132])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetWorkingDirectory")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetWorkingDirectory()
		{
			byte* ret = GetWorkingDirectoryNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetWorkingDirectory")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetWorkingDirectoryS()
		{
			string ret = Utils.DecodeStringUTF8(GetWorkingDirectoryNative());
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetApplicationDirectory")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetApplicationDirectoryNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[133])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[133])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetApplicationDirectory")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetApplicationDirectory()
		{
			byte* ret = GetApplicationDirectoryNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetApplicationDirectory")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetApplicationDirectoryS()
		{
			string ret = Utils.DecodeStringUTF8(GetApplicationDirectoryNative());
			return ret;
		}

		[NativeName(NativeNameType.Func, "MakeDirectory")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MakeDirectoryNative([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[134])(dirPath);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[134])((nint)dirPath);
			#endif
		}

		[NativeName(NativeNameType.Func, "MakeDirectory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int MakeDirectory([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			int ret = MakeDirectoryNative(dirPath);
			return ret;
		}

		[NativeName(NativeNameType.Func, "MakeDirectory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int MakeDirectory([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ref byte dirPath)
		{
			fixed (byte* pdirPath = &dirPath)
			{
				int ret = MakeDirectoryNative((byte*)pdirPath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "MakeDirectory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int MakeDirectory([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> dirPath)
		{
			fixed (byte* pdirPath = dirPath)
			{
				int ret = MakeDirectoryNative((byte*)pdirPath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "MakeDirectory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int MakeDirectory([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] string dirPath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dirPath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dirPath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dirPath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = MakeDirectoryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "ChangeDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ChangeDirectoryNative([NativeName(NativeNameType.Param, "dir")] [NativeName(NativeNameType.Type, "char const *")] byte* dir)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[135])(dir);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[135])((nint)dir);
			#endif
		}

		[NativeName(NativeNameType.Func, "ChangeDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ChangeDirectory([NativeName(NativeNameType.Param, "dir")] [NativeName(NativeNameType.Type, "char const *")] byte* dir)
		{
			byte ret = ChangeDirectoryNative(dir);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "ChangeDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ChangeDirectory([NativeName(NativeNameType.Param, "dir")] [NativeName(NativeNameType.Type, "char const *")] ref byte dir)
		{
			fixed (byte* pdir = &dir)
			{
				byte ret = ChangeDirectoryNative((byte*)pdir);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ChangeDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ChangeDirectory([NativeName(NativeNameType.Param, "dir")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> dir)
		{
			fixed (byte* pdir = dir)
			{
				byte ret = ChangeDirectoryNative((byte*)pdir);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ChangeDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ChangeDirectory([NativeName(NativeNameType.Param, "dir")] [NativeName(NativeNameType.Type, "char const *")] string dir)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dir != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dir);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dir, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ChangeDirectoryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsPathFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPathFileNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[136])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[136])((nint)path);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsPathFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPathFile([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			byte ret = IsPathFileNative(path);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsPathFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPathFile([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = IsPathFileNative((byte*)ppath);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "IsPathFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPathFile([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				byte ret = IsPathFileNative((byte*)ppath);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "IsPathFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPathFile([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsPathFileNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsFileNameValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFileNameValidNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[137])(fileName);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[137])((nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsFileNameValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileNameValid([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			byte ret = IsFileNameValidNative(fileName);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsFileNameValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileNameValid([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = IsFileNameValidNative((byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "IsFileNameValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileNameValid([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = IsFileNameValidNative((byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "IsFileNameValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileNameValid([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsFileNameValidNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFiles")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FilePathList LoadDirectoryFilesNative([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, FilePathList>)funcTable[138])(dirPath);
			#else
			return (FilePathList)((delegate* unmanaged[Cdecl]<nint, FilePathList>)funcTable[138])((nint)dirPath);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFiles")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFiles([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			FilePathList ret = LoadDirectoryFilesNative(dirPath);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFiles")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFiles([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ref byte dirPath)
		{
			fixed (byte* pdirPath = &dirPath)
			{
				FilePathList ret = LoadDirectoryFilesNative((byte*)pdirPath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFiles")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFiles([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> dirPath)
		{
			fixed (byte* pdirPath = dirPath)
			{
				FilePathList ret = LoadDirectoryFilesNative((byte*)pdirPath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFiles")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFiles([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] string dirPath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dirPath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dirPath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dirPath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			FilePathList ret = LoadDirectoryFilesNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FilePathList LoadDirectoryFilesExNative([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] byte* basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] byte* filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] byte scanSubdirs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte, FilePathList>)funcTable[139])(basePath, filter, scanSubdirs);
			#else
			return (FilePathList)((delegate* unmanaged[Cdecl]<nint, nint, byte, FilePathList>)funcTable[139])((nint)basePath, (nint)filter, scanSubdirs);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] byte* basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] byte* filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			FilePathList ret = LoadDirectoryFilesExNative(basePath, filter, scanSubdirs ? (byte)1 : (byte)0);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] ref byte basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] byte* filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			fixed (byte* pbasePath = &basePath)
			{
				FilePathList ret = LoadDirectoryFilesExNative((byte*)pbasePath, filter, scanSubdirs ? (byte)1 : (byte)0);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] byte* filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			fixed (byte* pbasePath = basePath)
			{
				FilePathList ret = LoadDirectoryFilesExNative((byte*)pbasePath, filter, scanSubdirs ? (byte)1 : (byte)0);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] string basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] byte* filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (basePath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(basePath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(basePath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			FilePathList ret = LoadDirectoryFilesExNative(pStr0, filter, scanSubdirs ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] byte* basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] ref byte filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			fixed (byte* pfilter = &filter)
			{
				FilePathList ret = LoadDirectoryFilesExNative(basePath, (byte*)pfilter, scanSubdirs ? (byte)1 : (byte)0);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] byte* basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			fixed (byte* pfilter = filter)
			{
				FilePathList ret = LoadDirectoryFilesExNative(basePath, (byte*)pfilter, scanSubdirs ? (byte)1 : (byte)0);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] byte* basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] string filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			FilePathList ret = LoadDirectoryFilesExNative(basePath, pStr0, scanSubdirs ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] ref byte basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] ref byte filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			fixed (byte* pbasePath = &basePath)
			{
				fixed (byte* pfilter = &filter)
				{
					FilePathList ret = LoadDirectoryFilesExNative((byte*)pbasePath, (byte*)pfilter, scanSubdirs ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			fixed (byte* pbasePath = basePath)
			{
				fixed (byte* pfilter = filter)
				{
					FilePathList ret = LoadDirectoryFilesExNative((byte*)pbasePath, (byte*)pfilter, scanSubdirs ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadDirectoryFilesEx")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDirectoryFilesEx([NativeName(NativeNameType.Param, "basePath")] [NativeName(NativeNameType.Type, "char const *")] string basePath, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "char const *")] string filter, [NativeName(NativeNameType.Param, "scanSubdirs")] [NativeName(NativeNameType.Type, "bool")] bool scanSubdirs)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (basePath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(basePath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(basePath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (filter != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(filter);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(filter, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			FilePathList ret = LoadDirectoryFilesExNative(pStr0, pStr1, scanSubdirs ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "UnloadDirectoryFiles")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadDirectoryFilesNative([NativeName(NativeNameType.Param, "files")] [NativeName(NativeNameType.Type, "FilePathList")] FilePathList files)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FilePathList, void>)funcTable[140])(files);
			#else
			((delegate* unmanaged[Cdecl]<FilePathList, void>)funcTable[140])(files);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadDirectoryFiles")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadDirectoryFiles([NativeName(NativeNameType.Param, "files")] [NativeName(NativeNameType.Type, "FilePathList")] FilePathList files)
		{
			UnloadDirectoryFilesNative(files);
		}

		[NativeName(NativeNameType.Func, "IsFileDropped")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFileDroppedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[141])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[141])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsFileDropped")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileDropped()
		{
			byte ret = IsFileDroppedNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "LoadDroppedFiles")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FilePathList LoadDroppedFilesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FilePathList>)funcTable[142])();
			#else
			return (FilePathList)((delegate* unmanaged[Cdecl]<FilePathList>)funcTable[142])();
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadDroppedFiles")]
		[return: NativeName(NativeNameType.Type, "FilePathList")]
		public static FilePathList LoadDroppedFiles()
		{
			FilePathList ret = LoadDroppedFilesNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "UnloadDroppedFiles")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadDroppedFilesNative([NativeName(NativeNameType.Param, "files")] [NativeName(NativeNameType.Type, "FilePathList")] FilePathList files)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FilePathList, void>)funcTable[143])(files);
			#else
			((delegate* unmanaged[Cdecl]<FilePathList, void>)funcTable[143])(files);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadDroppedFiles")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadDroppedFiles([NativeName(NativeNameType.Param, "files")] [NativeName(NativeNameType.Type, "FilePathList")] FilePathList files)
		{
			UnloadDroppedFilesNative(files);
		}

		[NativeName(NativeNameType.Func, "GetFileModTime")]
		[return: NativeName(NativeNameType.Type, "long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFileModTimeNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[144])(fileName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[144])((nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetFileModTime")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int GetFileModTime([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			int ret = GetFileModTimeNative(fileName);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileModTime")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int GetFileModTime([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				int ret = GetFileModTimeNative((byte*)pfileName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileModTime")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int GetFileModTime([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				int ret = GetFileModTimeNative((byte*)pfileName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileModTime")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int GetFileModTime([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFileModTimeNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CompressDataNative([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] int* compDataSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int*, byte*>)funcTable[145])(data, dataSize, compDataSize);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)funcTable[145])((nint)data, dataSize, (nint)compDataSize);
			#endif
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* CompressData([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] int* compDataSize)
		{
			byte* ret = CompressDataNative(data, dataSize, compDataSize);
			return ret;
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string CompressDataS([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] int* compDataSize)
		{
			string ret = Utils.DecodeStringUTF8(CompressDataNative(data, dataSize, compDataSize));
			return ret;
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* CompressData([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] int* compDataSize)
		{
			fixed (byte* pdata = &data)
			{
				byte* ret = CompressDataNative((byte*)pdata, dataSize, compDataSize);
				return ret;
			}
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string CompressDataS([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] int* compDataSize)
		{
			fixed (byte* pdata = &data)
			{
				string ret = Utils.DecodeStringUTF8(CompressDataNative((byte*)pdata, dataSize, compDataSize));
				return ret;
			}
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* CompressData([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] ref int compDataSize)
		{
			fixed (int* pcompDataSize = &compDataSize)
			{
				byte* ret = CompressDataNative(data, dataSize, (int*)pcompDataSize);
				return ret;
			}
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string CompressDataS([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] ref int compDataSize)
		{
			fixed (int* pcompDataSize = &compDataSize)
			{
				string ret = Utils.DecodeStringUTF8(CompressDataNative(data, dataSize, (int*)pcompDataSize));
				return ret;
			}
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* CompressData([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] ref int compDataSize)
		{
			fixed (byte* pdata = &data)
			{
				fixed (int* pcompDataSize = &compDataSize)
				{
					byte* ret = CompressDataNative((byte*)pdata, dataSize, (int*)pcompDataSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compression/Encoding functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string CompressDataS([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int *")] ref int compDataSize)
		{
			fixed (byte* pdata = &data)
			{
				fixed (int* pcompDataSize = &compDataSize)
				{
					string ret = Utils.DecodeStringUTF8(CompressDataNative((byte*)pdata, dataSize, (int*)pcompDataSize));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* DecompressDataNative([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int*, byte*>)funcTable[146])(compData, compDataSize, dataSize);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)funcTable[146])((nint)compData, compDataSize, (nint)dataSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* DecompressData([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			byte* ret = DecompressDataNative(compData, compDataSize, dataSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string DecompressDataS([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			string ret = Utils.DecodeStringUTF8(DecompressDataNative(compData, compDataSize, dataSize));
			return ret;
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* DecompressData([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			fixed (byte* pcompData = &compData)
			{
				byte* ret = DecompressDataNative((byte*)pcompData, compDataSize, dataSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string DecompressDataS([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			fixed (byte* pcompData = &compData)
			{
				string ret = Utils.DecodeStringUTF8(DecompressDataNative((byte*)pcompData, compDataSize, dataSize));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* DecompressData([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (int* pdataSize = &dataSize)
			{
				byte* ret = DecompressDataNative(compData, compDataSize, (int*)pdataSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string DecompressDataS([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (int* pdataSize = &dataSize)
			{
				string ret = Utils.DecodeStringUTF8(DecompressDataNative(compData, compDataSize, (int*)pdataSize));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* DecompressData([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (byte* pcompData = &compData)
			{
				fixed (int* pdataSize = &dataSize)
				{
					byte* ret = DecompressDataNative((byte*)pcompData, compDataSize, (int*)pdataSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "DecompressData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string DecompressDataS([NativeName(NativeNameType.Param, "compData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte compData, [NativeName(NativeNameType.Param, "compDataSize")] [NativeName(NativeNameType.Type, "int")] int compDataSize, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (byte* pcompData = &compData)
			{
				fixed (int* pdataSize = &dataSize)
				{
					string ret = Utils.DecodeStringUTF8(DecompressDataNative((byte*)pcompData, compDataSize, (int*)pdataSize));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* EncodeDataBase64Native([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int*, byte*>)funcTable[147])(data, dataSize, outputSize);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)funcTable[147])((nint)data, dataSize, (nint)outputSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* EncodeDataBase64([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			byte* ret = EncodeDataBase64Native(data, dataSize, outputSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string EncodeDataBase64S([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			string ret = Utils.DecodeStringUTF8(EncodeDataBase64Native(data, dataSize, outputSize));
			return ret;
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* EncodeDataBase64([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			fixed (byte* pdata = &data)
			{
				byte* ret = EncodeDataBase64Native((byte*)pdata, dataSize, outputSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string EncodeDataBase64S([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			fixed (byte* pdata = &data)
			{
				string ret = Utils.DecodeStringUTF8(EncodeDataBase64Native((byte*)pdata, dataSize, outputSize));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* EncodeDataBase64([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] ref int outputSize)
		{
			fixed (int* poutputSize = &outputSize)
			{
				byte* ret = EncodeDataBase64Native(data, dataSize, (int*)poutputSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string EncodeDataBase64S([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] ref int outputSize)
		{
			fixed (int* poutputSize = &outputSize)
			{
				string ret = Utils.DecodeStringUTF8(EncodeDataBase64Native(data, dataSize, (int*)poutputSize));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* EncodeDataBase64([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] ref int outputSize)
		{
			fixed (byte* pdata = &data)
			{
				fixed (int* poutputSize = &outputSize)
				{
					byte* ret = EncodeDataBase64Native((byte*)pdata, dataSize, (int*)poutputSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "EncodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string EncodeDataBase64S([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] ref int outputSize)
		{
			fixed (byte* pdata = &data)
			{
				fixed (int* poutputSize = &outputSize)
				{
					string ret = Utils.DecodeStringUTF8(EncodeDataBase64Native((byte*)pdata, dataSize, (int*)poutputSize));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* DecodeDataBase64Native([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, byte*>)funcTable[148])(data, outputSize);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[148])((nint)data, (nint)outputSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* DecodeDataBase64([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			byte* ret = DecodeDataBase64Native(data, outputSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string DecodeDataBase64S([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			string ret = Utils.DecodeStringUTF8(DecodeDataBase64Native(data, outputSize));
			return ret;
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* DecodeDataBase64([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			fixed (byte* pdata = &data)
			{
				byte* ret = DecodeDataBase64Native((byte*)pdata, outputSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string DecodeDataBase64S([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] int* outputSize)
		{
			fixed (byte* pdata = &data)
			{
				string ret = Utils.DecodeStringUTF8(DecodeDataBase64Native((byte*)pdata, outputSize));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* DecodeDataBase64([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] ref int outputSize)
		{
			fixed (int* poutputSize = &outputSize)
			{
				byte* ret = DecodeDataBase64Native(data, (int*)poutputSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string DecodeDataBase64S([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] ref int outputSize)
		{
			fixed (int* poutputSize = &outputSize)
			{
				string ret = Utils.DecodeStringUTF8(DecodeDataBase64Native(data, (int*)poutputSize));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* DecodeDataBase64([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] ref int outputSize)
		{
			fixed (byte* pdata = &data)
			{
				fixed (int* poutputSize = &outputSize)
				{
					byte* ret = DecodeDataBase64Native((byte*)pdata, (int*)poutputSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "DecodeDataBase64")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string DecodeDataBase64S([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "outputSize")] [NativeName(NativeNameType.Type, "int *")] ref int outputSize)
		{
			fixed (byte* pdata = &data)
			{
				fixed (int* poutputSize = &outputSize)
				{
					string ret = Utils.DecodeStringUTF8(DecodeDataBase64Native((byte*)pdata, (int*)poutputSize));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "ComputeCRC32")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ComputeCRC32Native([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, uint>)funcTable[149])(data, dataSize);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[149])((nint)data, dataSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "ComputeCRC32")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint ComputeCRC32([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			uint ret = ComputeCRC32Native(data, dataSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "ComputeCRC32")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint ComputeCRC32([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pdata = &data)
			{
				uint ret = ComputeCRC32Native((byte*)pdata, dataSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "ComputeMD5")]
		[return: NativeName(NativeNameType.Type, "unsigned int *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* ComputeMD5Native([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, uint*>)funcTable[150])(data, dataSize);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[150])((nint)data, dataSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "ComputeMD5")]
		[return: NativeName(NativeNameType.Type, "unsigned int *")]
		public static uint* ComputeMD5([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			uint* ret = ComputeMD5Native(data, dataSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "ComputeMD5")]
		[return: NativeName(NativeNameType.Type, "unsigned int *")]
		public static uint* ComputeMD5([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pdata = &data)
			{
				uint* ret = ComputeMD5Native((byte*)pdata, dataSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "ComputeSHA1")]
		[return: NativeName(NativeNameType.Type, "unsigned int *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* ComputeSHA1Native([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, uint*>)funcTable[151])(data, dataSize);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[151])((nint)data, dataSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "ComputeSHA1")]
		[return: NativeName(NativeNameType.Type, "unsigned int *")]
		public static uint* ComputeSHA1([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			uint* ret = ComputeSHA1Native(data, dataSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "ComputeSHA1")]
		[return: NativeName(NativeNameType.Type, "unsigned int *")]
		public static uint* ComputeSHA1([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pdata = &data)
			{
				uint* ret = ComputeSHA1Native((byte*)pdata, dataSize);
				return ret;
			}
		}

		/// <summary>
		/// Automation events functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "AutomationEventList")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AutomationEventList LoadAutomationEventListNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, AutomationEventList>)funcTable[152])(fileName);
			#else
			return (AutomationEventList)((delegate* unmanaged[Cdecl]<nint, AutomationEventList>)funcTable[152])((nint)fileName);
			#endif
		}

		/// <summary>
		/// Automation events functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "AutomationEventList")]
		public static AutomationEventList LoadAutomationEventList([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			AutomationEventList ret = LoadAutomationEventListNative(fileName);
			return ret;
		}

		/// <summary>
		/// Automation events functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "AutomationEventList")]
		public static AutomationEventList LoadAutomationEventList([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				AutomationEventList ret = LoadAutomationEventListNative((byte*)pfileName);
				return ret;
			}
		}

		/// <summary>
		/// Automation events functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "AutomationEventList")]
		public static AutomationEventList LoadAutomationEventList([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				AutomationEventList ret = LoadAutomationEventListNative((byte*)pfileName);
				return ret;
			}
		}

		/// <summary>
		/// Automation events functionality<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "AutomationEventList")]
		public static AutomationEventList LoadAutomationEventList([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AutomationEventList ret = LoadAutomationEventListNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "UnloadAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadAutomationEventListNative([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList")] AutomationEventList list)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AutomationEventList, void>)funcTable[153])(list);
			#else
			((delegate* unmanaged[Cdecl]<AutomationEventList, void>)funcTable[153])(list);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadAutomationEventList([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList")] AutomationEventList list)
		{
			UnloadAutomationEventListNative(list);
		}

		[NativeName(NativeNameType.Func, "ExportAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ExportAutomationEventListNative([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList")] AutomationEventList list, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AutomationEventList, byte*, byte>)funcTable[154])(list, fileName);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<AutomationEventList, nint, byte>)funcTable[154])(list, (nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "ExportAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportAutomationEventList([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList")] AutomationEventList list, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			byte ret = ExportAutomationEventListNative(list, fileName);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "ExportAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportAutomationEventList([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList")] AutomationEventList list, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = ExportAutomationEventListNative(list, (byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportAutomationEventList([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList")] AutomationEventList list, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = ExportAutomationEventListNative(list, (byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportAutomationEventList([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList")] AutomationEventList list, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ExportAutomationEventListNative(list, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SetAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAutomationEventListNative([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList *")] AutomationEventList* list)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AutomationEventList*, void>)funcTable[155])(list);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[155])((nint)list);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAutomationEventList([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList *")] AutomationEventList* list)
		{
			SetAutomationEventListNative(list);
		}

		[NativeName(NativeNameType.Func, "SetAutomationEventList")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAutomationEventList([NativeName(NativeNameType.Param, "list")] [NativeName(NativeNameType.Type, "AutomationEventList *")] ref AutomationEventList list)
		{
			fixed (AutomationEventList* plist = &list)
			{
				SetAutomationEventListNative((AutomationEventList*)plist);
			}
		}

		[NativeName(NativeNameType.Func, "SetAutomationEventBaseFrame")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAutomationEventBaseFrameNative([NativeName(NativeNameType.Param, "frame")] [NativeName(NativeNameType.Type, "int")] int frame)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[156])(frame);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[156])(frame);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetAutomationEventBaseFrame")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAutomationEventBaseFrame([NativeName(NativeNameType.Param, "frame")] [NativeName(NativeNameType.Type, "int")] int frame)
		{
			SetAutomationEventBaseFrameNative(frame);
		}

		[NativeName(NativeNameType.Func, "StartAutomationEventRecording")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StartAutomationEventRecordingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[157])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[157])();
			#endif
		}

		[NativeName(NativeNameType.Func, "StartAutomationEventRecording")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StartAutomationEventRecording()
		{
			StartAutomationEventRecordingNative();
		}

		[NativeName(NativeNameType.Func, "StopAutomationEventRecording")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StopAutomationEventRecordingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[158])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[158])();
			#endif
		}

		[NativeName(NativeNameType.Func, "StopAutomationEventRecording")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StopAutomationEventRecording()
		{
			StopAutomationEventRecordingNative();
		}

		[NativeName(NativeNameType.Func, "PlayAutomationEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PlayAutomationEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "AutomationEvent")] AutomationEvent evnt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AutomationEvent, void>)funcTable[159])(evnt);
			#else
			((delegate* unmanaged[Cdecl]<AutomationEvent, void>)funcTable[159])(evnt);
			#endif
		}

		[NativeName(NativeNameType.Func, "PlayAutomationEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PlayAutomationEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "AutomationEvent")] AutomationEvent evnt)
		{
			PlayAutomationEventNative(evnt);
		}

		/// <summary>
		/// Input-related functions: keyboard<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IsKeyPressed")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyPressedNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[160])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[160])(key);
			#endif
		}

		/// <summary>
		/// Input-related functions: keyboard<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IsKeyPressed")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyPressed([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			byte ret = IsKeyPressedNative(key);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsKeyPressedRepeat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyPressedRepeatNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[161])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[161])(key);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsKeyPressedRepeat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyPressedRepeat([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			byte ret = IsKeyPressedRepeatNative(key);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsKeyDown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyDownNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[162])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[162])(key);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsKeyDown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyDown([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			byte ret = IsKeyDownNative(key);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsKeyReleased")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyReleasedNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[163])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[163])(key);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsKeyReleased")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyReleased([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			byte ret = IsKeyReleasedNative(key);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsKeyUp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyUpNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[164])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[164])(key);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsKeyUp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyUp([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			byte ret = IsKeyUpNative(key);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "GetKeyPressed")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyPressedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[165])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[165])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetKeyPressed")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetKeyPressed()
		{
			int ret = GetKeyPressedNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCharPressed")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCharPressedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[166])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[166])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCharPressed")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCharPressed()
		{
			int ret = GetCharPressedNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "SetExitKey")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetExitKeyNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[167])(key);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[167])(key);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetExitKey")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetExitKey([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key)
		{
			SetExitKeyNative(key);
		}

		/// <summary>
		/// Input-related functions: gamepads<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IsGamepadAvailable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsGamepadAvailableNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[168])(gamepad);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[168])(gamepad);
			#endif
		}

		/// <summary>
		/// Input-related functions: gamepads<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IsGamepadAvailable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsGamepadAvailable([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad)
		{
			byte ret = IsGamepadAvailableNative(gamepad);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "GetGamepadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadNameNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[169])(gamepad);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[169])(gamepad);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGamepadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadName([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad)
		{
			byte* ret = GetGamepadNameNative(gamepad);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGamepadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadNameS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadNameNative(gamepad));
			return ret;
		}

		[NativeName(NativeNameType.Func, "IsGamepadButtonPressed")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsGamepadButtonPressedNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte>)funcTable[170])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, byte>)funcTable[170])(gamepad, button);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsGamepadButtonPressed")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsGamepadButtonPressed([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = IsGamepadButtonPressedNative(gamepad, button);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsGamepadButtonDown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsGamepadButtonDownNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte>)funcTable[171])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, byte>)funcTable[171])(gamepad, button);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsGamepadButtonDown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsGamepadButtonDown([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = IsGamepadButtonDownNative(gamepad, button);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsGamepadButtonReleased")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsGamepadButtonReleasedNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte>)funcTable[172])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, byte>)funcTable[172])(gamepad, button);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsGamepadButtonReleased")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsGamepadButtonReleased([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = IsGamepadButtonReleasedNative(gamepad, button);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsGamepadButtonUp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsGamepadButtonUpNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte>)funcTable[173])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, int, byte>)funcTable[173])(gamepad, button);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsGamepadButtonUp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsGamepadButtonUp([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = IsGamepadButtonUpNative(gamepad, button);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "GetGamepadButtonPressed")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadButtonPressedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[174])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[174])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGamepadButtonPressed")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadButtonPressed()
		{
			int ret = GetGamepadButtonPressedNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGamepadAxisCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadAxisCountNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[175])(gamepad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[175])(gamepad);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGamepadAxisCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadAxisCount([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad)
		{
			int ret = GetGamepadAxisCountNative(gamepad);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGamepadAxisMovement")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetGamepadAxisMovementNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, float>)funcTable[176])(gamepad, axis);
			#else
			return (float)((delegate* unmanaged[Cdecl]<int, int, float>)funcTable[176])(gamepad, axis);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGamepadAxisMovement")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetGamepadAxisMovement([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis)
		{
			float ret = GetGamepadAxisMovementNative(gamepad, axis);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SetGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetGamepadMappingsNative([NativeName(NativeNameType.Param, "mappings")] [NativeName(NativeNameType.Type, "char const *")] byte* mappings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[177])(mappings);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[177])((nint)mappings);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetGamepadMappings([NativeName(NativeNameType.Param, "mappings")] [NativeName(NativeNameType.Type, "char const *")] byte* mappings)
		{
			int ret = SetGamepadMappingsNative(mappings);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SetGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetGamepadMappings([NativeName(NativeNameType.Param, "mappings")] [NativeName(NativeNameType.Type, "char const *")] ref byte mappings)
		{
			fixed (byte* pmappings = &mappings)
			{
				int ret = SetGamepadMappingsNative((byte*)pmappings);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SetGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetGamepadMappings([NativeName(NativeNameType.Param, "mappings")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mappings)
		{
			fixed (byte* pmappings = mappings)
			{
				int ret = SetGamepadMappingsNative((byte*)pmappings);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SetGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetGamepadMappings([NativeName(NativeNameType.Param, "mappings")] [NativeName(NativeNameType.Type, "char const *")] string mappings)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mappings != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mappings);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mappings, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetGamepadMappingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SetGamepadVibration")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGamepadVibrationNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "leftMotor")] [NativeName(NativeNameType.Type, "float")] float leftMotor, [NativeName(NativeNameType.Param, "rightMotor")] [NativeName(NativeNameType.Type, "float")] float rightMotor, [NativeName(NativeNameType.Param, "duration")] [NativeName(NativeNameType.Type, "float")] float duration)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[178])(gamepad, leftMotor, rightMotor, duration);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[178])(gamepad, leftMotor, rightMotor, duration);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetGamepadVibration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGamepadVibration([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "int")] int gamepad, [NativeName(NativeNameType.Param, "leftMotor")] [NativeName(NativeNameType.Type, "float")] float leftMotor, [NativeName(NativeNameType.Param, "rightMotor")] [NativeName(NativeNameType.Type, "float")] float rightMotor, [NativeName(NativeNameType.Param, "duration")] [NativeName(NativeNameType.Type, "float")] float duration)
		{
			SetGamepadVibrationNative(gamepad, leftMotor, rightMotor, duration);
		}

		/// <summary>
		/// Input-related functions: mouse<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IsMouseButtonPressed")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseButtonPressedNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[179])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[179])(button);
			#endif
		}

		/// <summary>
		/// Input-related functions: mouse<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IsMouseButtonPressed")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseButtonPressed([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = IsMouseButtonPressedNative(button);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsMouseButtonDown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseButtonDownNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[180])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[180])(button);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsMouseButtonDown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseButtonDown([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = IsMouseButtonDownNative(button);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsMouseButtonReleased")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseButtonReleasedNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[181])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[181])(button);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsMouseButtonReleased")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseButtonReleased([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = IsMouseButtonReleasedNative(button);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsMouseButtonUp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseButtonUpNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[182])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[182])(button);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsMouseButtonUp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseButtonUp([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = IsMouseButtonUpNative(button);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "GetMouseX")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMouseXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[183])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[183])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMouseX")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMouseX()
		{
			int ret = GetMouseXNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMouseY")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMouseYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[184])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[184])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMouseY")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMouseY()
		{
			int ret = GetMouseYNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMousePosition")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetMousePositionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2>)funcTable[185])();
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2>)funcTable[185])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMousePosition")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetMousePosition()
		{
			Vector2 ret = GetMousePositionNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMouseDelta")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetMouseDeltaNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2>)funcTable[186])();
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2>)funcTable[186])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMouseDelta")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetMouseDelta()
		{
			Vector2 ret = GetMouseDeltaNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "SetMousePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMousePositionNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[187])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[187])(x, y);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetMousePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetMousePosition([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			SetMousePositionNative(x, y);
		}

		[NativeName(NativeNameType.Func, "SetMouseOffset")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMouseOffsetNative([NativeName(NativeNameType.Param, "offsetX")] [NativeName(NativeNameType.Type, "int")] int offsetX, [NativeName(NativeNameType.Param, "offsetY")] [NativeName(NativeNameType.Type, "int")] int offsetY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[188])(offsetX, offsetY);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[188])(offsetX, offsetY);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetMouseOffset")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetMouseOffset([NativeName(NativeNameType.Param, "offsetX")] [NativeName(NativeNameType.Type, "int")] int offsetX, [NativeName(NativeNameType.Param, "offsetY")] [NativeName(NativeNameType.Type, "int")] int offsetY)
		{
			SetMouseOffsetNative(offsetX, offsetY);
		}

		[NativeName(NativeNameType.Func, "SetMouseScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMouseScaleNative([NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[189])(scaleX, scaleY);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[189])(scaleX, scaleY);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetMouseScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetMouseScale([NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			SetMouseScaleNative(scaleX, scaleY);
		}

		[NativeName(NativeNameType.Func, "GetMouseWheelMove")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetMouseWheelMoveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[190])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[190])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMouseWheelMove")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetMouseWheelMove()
		{
			float ret = GetMouseWheelMoveNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMouseWheelMoveV")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetMouseWheelMoveVNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2>)funcTable[191])();
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2>)funcTable[191])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMouseWheelMoveV")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetMouseWheelMoveV()
		{
			Vector2 ret = GetMouseWheelMoveVNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "SetMouseCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMouseCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[192])(cursor);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[192])(cursor);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetMouseCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetMouseCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "int")] int cursor)
		{
			SetMouseCursorNative(cursor);
		}

		/// <summary>
		/// Input-related functions: touch<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "GetTouchX")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTouchXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[193])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[193])();
			#endif
		}

		/// <summary>
		/// Input-related functions: touch<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "GetTouchX")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTouchX()
		{
			int ret = GetTouchXNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetTouchY")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTouchYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[194])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[194])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetTouchY")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTouchY()
		{
			int ret = GetTouchYNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetTouchPosition")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetTouchPositionNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, Vector2>)funcTable[195])(index);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<int, Vector2>)funcTable[195])(index);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetTouchPosition")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetTouchPosition([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			Vector2 ret = GetTouchPositionNative(index);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetTouchPointId")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTouchPointIdNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[196])(index);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[196])(index);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetTouchPointId")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTouchPointId([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			int ret = GetTouchPointIdNative(index);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetTouchPointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTouchPointCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[197])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[197])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetTouchPointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetTouchPointCount()
		{
			int ret = GetTouchPointCountNative();
			return ret;
		}

		/// <summary>
		/// ------------------------------------------------------------------------------------<br/>
		/// Gestures and Touch Handling Functions (Module: rgestures)<br/>
		/// ------------------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetGesturesEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGesturesEnabledNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "unsigned int")] uint flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[198])(flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[198])(flags);
			#endif
		}

		/// <summary>
		/// ------------------------------------------------------------------------------------<br/>
		/// Gestures and Touch Handling Functions (Module: rgestures)<br/>
		/// ------------------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetGesturesEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGesturesEnabled([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "unsigned int")] uint flags)
		{
			SetGesturesEnabledNative(flags);
		}

		[NativeName(NativeNameType.Func, "IsGestureDetected")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsGestureDetectedNative([NativeName(NativeNameType.Param, "gesture")] [NativeName(NativeNameType.Type, "unsigned int")] uint gesture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[199])(gesture);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[199])(gesture);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsGestureDetected")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsGestureDetected([NativeName(NativeNameType.Param, "gesture")] [NativeName(NativeNameType.Type, "unsigned int")] uint gesture)
		{
			byte ret = IsGestureDetectedNative(gesture);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "GetGestureDetected")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGestureDetectedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[200])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[200])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGestureDetected")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGestureDetected()
		{
			int ret = GetGestureDetectedNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGestureHoldDuration")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetGestureHoldDurationNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[201])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[201])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGestureHoldDuration")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetGestureHoldDuration()
		{
			float ret = GetGestureHoldDurationNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGestureDragVector")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetGestureDragVectorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2>)funcTable[202])();
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2>)funcTable[202])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGestureDragVector")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetGestureDragVector()
		{
			Vector2 ret = GetGestureDragVectorNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGestureDragAngle")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetGestureDragAngleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[203])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[203])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGestureDragAngle")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetGestureDragAngle()
		{
			float ret = GetGestureDragAngleNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGesturePinchVector")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetGesturePinchVectorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2>)funcTable[204])();
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2>)funcTable[204])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGesturePinchVector")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetGesturePinchVector()
		{
			Vector2 ret = GetGesturePinchVectorNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetGesturePinchAngle")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetGesturePinchAngleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[205])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[205])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetGesturePinchAngle")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetGesturePinchAngle()
		{
			float ret = GetGesturePinchAngleNative();
			return ret;
		}

		/// <summary>
		/// ------------------------------------------------------------------------------------<br/>
		/// Camera System Functions (Module: rcamera)<br/>
		/// ------------------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "UpdateCamera")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateCameraNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera *")] Camera3D* camera, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "int")] int mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Camera3D*, int, void>)funcTable[206])(camera, mode);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[206])((nint)camera, mode);
			#endif
		}

		/// <summary>
		/// ------------------------------------------------------------------------------------<br/>
		/// Camera System Functions (Module: rcamera)<br/>
		/// ------------------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "UpdateCamera")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateCamera([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera *")] Camera3D* camera, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "int")] int mode)
		{
			UpdateCameraNative(camera, mode);
		}

		/// <summary>
		/// ------------------------------------------------------------------------------------<br/>
		/// Camera System Functions (Module: rcamera)<br/>
		/// ------------------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "UpdateCamera")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateCamera([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera *")] ref Camera3D camera, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "int")] int mode)
		{
			fixed (Camera3D* pcamera = &camera)
			{
				UpdateCameraNative((Camera3D*)pcamera, mode);
			}
		}

		[NativeName(NativeNameType.Func, "UpdateCameraPro")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateCameraProNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera *")] Camera3D* camera, [NativeName(NativeNameType.Param, "movement")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 movement, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotation, [NativeName(NativeNameType.Param, "zoom")] [NativeName(NativeNameType.Type, "float")] float zoom)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Camera3D*, Vector3, Vector3, float, void>)funcTable[207])(camera, movement, rotation, zoom);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector3, Vector3, float, void>)funcTable[207])((nint)camera, movement, rotation, zoom);
			#endif
		}

		[NativeName(NativeNameType.Func, "UpdateCameraPro")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateCameraPro([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera *")] Camera3D* camera, [NativeName(NativeNameType.Param, "movement")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 movement, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotation, [NativeName(NativeNameType.Param, "zoom")] [NativeName(NativeNameType.Type, "float")] float zoom)
		{
			UpdateCameraProNative(camera, movement, rotation, zoom);
		}

		[NativeName(NativeNameType.Func, "UpdateCameraPro")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateCameraPro([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera *")] ref Camera3D camera, [NativeName(NativeNameType.Param, "movement")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 movement, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 rotation, [NativeName(NativeNameType.Param, "zoom")] [NativeName(NativeNameType.Type, "float")] float zoom)
		{
			fixed (Camera3D* pcamera = &camera)
			{
				UpdateCameraProNative((Camera3D*)pcamera, movement, rotation, zoom);
			}
		}

		/// <summary>
		/// ------------------------------------------------------------------------------------<br/>
		/// Basic Shapes Drawing Functions (Module: shapes)<br/>
		/// ------------------------------------------------------------------------------------<br/>
		/// Set texture and rectangle to be used on shapes drawing<br/>
		/// NOTE: It can be useful when using basic shapes and one single font,<br/>
		/// defining a font char white rectangle would allow drawing everything in a single draw call<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetShapesTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetShapesTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle source)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Texture, Rectangle, void>)funcTable[208])(texture, source);
			#else
			((delegate* unmanaged[Cdecl]<Texture, Rectangle, void>)funcTable[208])(texture, source);
			#endif
		}

		/// <summary>
		/// ------------------------------------------------------------------------------------<br/>
		/// Basic Shapes Drawing Functions (Module: shapes)<br/>
		/// ------------------------------------------------------------------------------------<br/>
		/// Set texture and rectangle to be used on shapes drawing<br/>
		/// NOTE: It can be useful when using basic shapes and one single font,<br/>
		/// defining a font char white rectangle would allow drawing everything in a single draw call<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetShapesTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetShapesTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle source)
		{
			SetShapesTextureNative(texture, source);
		}

		[NativeName(NativeNameType.Func, "GetShapesTexture")]
		[return: NativeName(NativeNameType.Type, "Texture2D")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Texture GetShapesTextureNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Texture>)funcTable[209])();
			#else
			return (Texture)((delegate* unmanaged[Cdecl]<Texture>)funcTable[209])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetShapesTexture")]
		[return: NativeName(NativeNameType.Type, "Texture2D")]
		public static Texture GetShapesTexture()
		{
			Texture ret = GetShapesTextureNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetShapesTextureRectangle")]
		[return: NativeName(NativeNameType.Type, "Rectangle")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Rectangle GetShapesTextureRectangleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Rectangle>)funcTable[210])();
			#else
			return (Rectangle)((delegate* unmanaged[Cdecl]<Rectangle>)funcTable[210])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetShapesTextureRectangle")]
		[return: NativeName(NativeNameType.Type, "Rectangle")]
		public static Rectangle GetShapesTextureRectangle()
		{
			Rectangle ret = GetShapesTextureRectangleNative();
			return ret;
		}

		/// <summary>
		/// Basic shapes drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawPixel")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawPixelNative([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, Color, void>)funcTable[211])(posX, posY, color);
			#else
			((delegate* unmanaged[Cdecl]<int, int, Color, void>)funcTable[211])(posX, posY, color);
			#endif
		}

		/// <summary>
		/// Basic shapes drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawPixel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawPixel([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawPixelNative(posX, posY, color);
		}

		[NativeName(NativeNameType.Func, "DrawPixelV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawPixelVNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Color, void>)funcTable[212])(position, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Color, void>)funcTable[212])(position, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawPixelV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawPixelV([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawPixelVNative(position, color);
		}

		[NativeName(NativeNameType.Func, "DrawLine")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawLineNative([NativeName(NativeNameType.Param, "startPosX")] [NativeName(NativeNameType.Type, "int")] int startPosX, [NativeName(NativeNameType.Param, "startPosY")] [NativeName(NativeNameType.Type, "int")] int startPosY, [NativeName(NativeNameType.Param, "endPosX")] [NativeName(NativeNameType.Type, "int")] int endPosX, [NativeName(NativeNameType.Param, "endPosY")] [NativeName(NativeNameType.Type, "int")] int endPosY, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, void>)funcTable[213])(startPosX, startPosY, endPosX, endPosY, color);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, void>)funcTable[213])(startPosX, startPosY, endPosX, endPosY, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawLine")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawLine([NativeName(NativeNameType.Param, "startPosX")] [NativeName(NativeNameType.Type, "int")] int startPosX, [NativeName(NativeNameType.Param, "startPosY")] [NativeName(NativeNameType.Type, "int")] int startPosY, [NativeName(NativeNameType.Param, "endPosX")] [NativeName(NativeNameType.Type, "int")] int endPosX, [NativeName(NativeNameType.Param, "endPosY")] [NativeName(NativeNameType.Type, "int")] int endPosY, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawLineNative(startPosX, startPosY, endPosX, endPosY, color);
		}

		[NativeName(NativeNameType.Func, "DrawLineV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawLineVNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Color, void>)funcTable[214])(startPos, endPos, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Color, void>)funcTable[214])(startPos, endPos, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawLineV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawLineV([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawLineVNative(startPos, endPos, color);
		}

		[NativeName(NativeNameType.Func, "DrawLineEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawLineExNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, Color, void>)funcTable[215])(startPos, endPos, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, Color, void>)funcTable[215])(startPos, endPos, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawLineEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawLineEx([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawLineExNative(startPos, endPos, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawLineStrip")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawLineStripNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, int, Color, void>)funcTable[216])(points, pointCount, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, Color, void>)funcTable[216])((nint)points, pointCount, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawLineStrip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawLineStrip([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawLineStripNative(points, pointCount, color);
		}

		[NativeName(NativeNameType.Func, "DrawLineStrip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawLineStrip([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector2* ppoints = &points)
			{
				DrawLineStripNative((Vector2*)ppoints, pointCount, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawLineBezier")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawLineBezierNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, Color, void>)funcTable[217])(startPos, endPos, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, Color, void>)funcTable[217])(startPos, endPos, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawLineBezier")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawLineBezier([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawLineBezierNative(startPos, endPos, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCircleNative([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float, Color, void>)funcTable[218])(centerX, centerY, radius, color);
			#else
			((delegate* unmanaged[Cdecl]<int, int, float, Color, void>)funcTable[218])(centerX, centerY, radius, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircle([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCircleNative(centerX, centerY, radius, color);
		}

		[NativeName(NativeNameType.Func, "DrawCircleSector")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCircleSectorNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "startAngle")] [NativeName(NativeNameType.Type, "float")] float startAngle, [NativeName(NativeNameType.Param, "endAngle")] [NativeName(NativeNameType.Type, "float")] float endAngle, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, float, float, float, int, Color, void>)funcTable[219])(center, radius, startAngle, endAngle, segments, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, float, float, float, int, Color, void>)funcTable[219])(center, radius, startAngle, endAngle, segments, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircleSector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircleSector([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "startAngle")] [NativeName(NativeNameType.Type, "float")] float startAngle, [NativeName(NativeNameType.Param, "endAngle")] [NativeName(NativeNameType.Type, "float")] float endAngle, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCircleSectorNative(center, radius, startAngle, endAngle, segments, color);
		}

		[NativeName(NativeNameType.Func, "DrawCircleSectorLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCircleSectorLinesNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "startAngle")] [NativeName(NativeNameType.Type, "float")] float startAngle, [NativeName(NativeNameType.Param, "endAngle")] [NativeName(NativeNameType.Type, "float")] float endAngle, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, float, float, float, int, Color, void>)funcTable[220])(center, radius, startAngle, endAngle, segments, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, float, float, float, int, Color, void>)funcTable[220])(center, radius, startAngle, endAngle, segments, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircleSectorLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircleSectorLines([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "startAngle")] [NativeName(NativeNameType.Type, "float")] float startAngle, [NativeName(NativeNameType.Param, "endAngle")] [NativeName(NativeNameType.Type, "float")] float endAngle, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCircleSectorLinesNative(center, radius, startAngle, endAngle, segments, color);
		}

		[NativeName(NativeNameType.Func, "DrawCircleGradient")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCircleGradientNative([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "inner")] [NativeName(NativeNameType.Type, "Color")] Color inner, [NativeName(NativeNameType.Param, "outer")] [NativeName(NativeNameType.Type, "Color")] Color outer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float, Color, Color, void>)funcTable[221])(centerX, centerY, radius, inner, outer);
			#else
			((delegate* unmanaged[Cdecl]<int, int, float, Color, Color, void>)funcTable[221])(centerX, centerY, radius, inner, outer);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircleGradient")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircleGradient([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "inner")] [NativeName(NativeNameType.Type, "Color")] Color inner, [NativeName(NativeNameType.Param, "outer")] [NativeName(NativeNameType.Type, "Color")] Color outer)
		{
			DrawCircleGradientNative(centerX, centerY, radius, inner, outer);
		}

		[NativeName(NativeNameType.Func, "DrawCircleV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCircleVNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, float, Color, void>)funcTable[222])(center, radius, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, float, Color, void>)funcTable[222])(center, radius, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircleV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircleV([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCircleVNative(center, radius, color);
		}

		[NativeName(NativeNameType.Func, "DrawCircleLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCircleLinesNative([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float, Color, void>)funcTable[223])(centerX, centerY, radius, color);
			#else
			((delegate* unmanaged[Cdecl]<int, int, float, Color, void>)funcTable[223])(centerX, centerY, radius, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircleLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircleLines([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCircleLinesNative(centerX, centerY, radius, color);
		}

		[NativeName(NativeNameType.Func, "DrawCircleLinesV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCircleLinesVNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, float, Color, void>)funcTable[224])(center, radius, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, float, Color, void>)funcTable[224])(center, radius, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawCircleLinesV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawCircleLinesV([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawCircleLinesVNative(center, radius, color);
		}

		[NativeName(NativeNameType.Func, "DrawEllipse")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawEllipseNative([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radiusH")] [NativeName(NativeNameType.Type, "float")] float radiusH, [NativeName(NativeNameType.Param, "radiusV")] [NativeName(NativeNameType.Type, "float")] float radiusV, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float, float, Color, void>)funcTable[225])(centerX, centerY, radiusH, radiusV, color);
			#else
			((delegate* unmanaged[Cdecl]<int, int, float, float, Color, void>)funcTable[225])(centerX, centerY, radiusH, radiusV, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawEllipse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawEllipse([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radiusH")] [NativeName(NativeNameType.Type, "float")] float radiusH, [NativeName(NativeNameType.Param, "radiusV")] [NativeName(NativeNameType.Type, "float")] float radiusV, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawEllipseNative(centerX, centerY, radiusH, radiusV, color);
		}

		[NativeName(NativeNameType.Func, "DrawEllipseLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawEllipseLinesNative([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radiusH")] [NativeName(NativeNameType.Type, "float")] float radiusH, [NativeName(NativeNameType.Param, "radiusV")] [NativeName(NativeNameType.Type, "float")] float radiusV, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float, float, Color, void>)funcTable[226])(centerX, centerY, radiusH, radiusV, color);
			#else
			((delegate* unmanaged[Cdecl]<int, int, float, float, Color, void>)funcTable[226])(centerX, centerY, radiusH, radiusV, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawEllipseLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawEllipseLines([NativeName(NativeNameType.Param, "centerX")] [NativeName(NativeNameType.Type, "int")] int centerX, [NativeName(NativeNameType.Param, "centerY")] [NativeName(NativeNameType.Type, "int")] int centerY, [NativeName(NativeNameType.Param, "radiusH")] [NativeName(NativeNameType.Type, "float")] float radiusH, [NativeName(NativeNameType.Param, "radiusV")] [NativeName(NativeNameType.Type, "float")] float radiusV, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawEllipseLinesNative(centerX, centerY, radiusH, radiusV, color);
		}

		[NativeName(NativeNameType.Func, "DrawRing")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRingNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "innerRadius")] [NativeName(NativeNameType.Type, "float")] float innerRadius, [NativeName(NativeNameType.Param, "outerRadius")] [NativeName(NativeNameType.Type, "float")] float outerRadius, [NativeName(NativeNameType.Param, "startAngle")] [NativeName(NativeNameType.Type, "float")] float startAngle, [NativeName(NativeNameType.Param, "endAngle")] [NativeName(NativeNameType.Type, "float")] float endAngle, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, float, float, float, float, int, Color, void>)funcTable[227])(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, float, float, float, float, int, Color, void>)funcTable[227])(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRing")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRing([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "innerRadius")] [NativeName(NativeNameType.Type, "float")] float innerRadius, [NativeName(NativeNameType.Param, "outerRadius")] [NativeName(NativeNameType.Type, "float")] float outerRadius, [NativeName(NativeNameType.Param, "startAngle")] [NativeName(NativeNameType.Type, "float")] float startAngle, [NativeName(NativeNameType.Param, "endAngle")] [NativeName(NativeNameType.Type, "float")] float endAngle, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRingNative(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
		}

		[NativeName(NativeNameType.Func, "DrawRingLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRingLinesNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "innerRadius")] [NativeName(NativeNameType.Type, "float")] float innerRadius, [NativeName(NativeNameType.Param, "outerRadius")] [NativeName(NativeNameType.Type, "float")] float outerRadius, [NativeName(NativeNameType.Param, "startAngle")] [NativeName(NativeNameType.Type, "float")] float startAngle, [NativeName(NativeNameType.Param, "endAngle")] [NativeName(NativeNameType.Type, "float")] float endAngle, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, float, float, float, float, int, Color, void>)funcTable[228])(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, float, float, float, float, int, Color, void>)funcTable[228])(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRingLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRingLines([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "innerRadius")] [NativeName(NativeNameType.Type, "float")] float innerRadius, [NativeName(NativeNameType.Param, "outerRadius")] [NativeName(NativeNameType.Type, "float")] float outerRadius, [NativeName(NativeNameType.Param, "startAngle")] [NativeName(NativeNameType.Type, "float")] float startAngle, [NativeName(NativeNameType.Param, "endAngle")] [NativeName(NativeNameType.Type, "float")] float endAngle, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRingLinesNative(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectangle")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleNative([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, void>)funcTable[229])(posX, posY, width, height, color);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, void>)funcTable[229])(posX, posY, width, height, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangle([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleNative(posX, posY, width, height, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleVNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Color, void>)funcTable[230])(position, size, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Color, void>)funcTable[230])(position, size, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleV([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 size, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleVNative(position, size, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleRec")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleRecNative([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Rectangle, Color, void>)funcTable[231])(rec, color);
			#else
			((delegate* unmanaged[Cdecl]<Rectangle, Color, void>)funcTable[231])(rec, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleRec")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleRec([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleRecNative(rec, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectanglePro")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleProNative([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 origin, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Rectangle, Vector2, float, Color, void>)funcTable[232])(rec, origin, rotation, color);
			#else
			((delegate* unmanaged[Cdecl]<Rectangle, Vector2, float, Color, void>)funcTable[232])(rec, origin, rotation, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectanglePro")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectanglePro([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 origin, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleProNative(rec, origin, rotation, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleGradientV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleGradientVNative([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "Color")] Color top, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "Color")] Color bottom)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, Color, void>)funcTable[233])(posX, posY, width, height, top, bottom);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, Color, void>)funcTable[233])(posX, posY, width, height, top, bottom);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleGradientV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleGradientV([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "Color")] Color top, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "Color")] Color bottom)
		{
			DrawRectangleGradientVNative(posX, posY, width, height, top, bottom);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleGradientH")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleGradientHNative([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "Color")] Color left, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "Color")] Color right)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, Color, void>)funcTable[234])(posX, posY, width, height, left, right);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, Color, void>)funcTable[234])(posX, posY, width, height, left, right);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleGradientH")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleGradientH([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "Color")] Color left, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "Color")] Color right)
		{
			DrawRectangleGradientHNative(posX, posY, width, height, left, right);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleGradientEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleGradientExNative([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "topLeft")] [NativeName(NativeNameType.Type, "Color")] Color topLeft, [NativeName(NativeNameType.Param, "bottomLeft")] [NativeName(NativeNameType.Type, "Color")] Color bottomLeft, [NativeName(NativeNameType.Param, "topRight")] [NativeName(NativeNameType.Type, "Color")] Color topRight, [NativeName(NativeNameType.Param, "bottomRight")] [NativeName(NativeNameType.Type, "Color")] Color bottomRight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Rectangle, Color, Color, Color, Color, void>)funcTable[235])(rec, topLeft, bottomLeft, topRight, bottomRight);
			#else
			((delegate* unmanaged[Cdecl]<Rectangle, Color, Color, Color, Color, void>)funcTable[235])(rec, topLeft, bottomLeft, topRight, bottomRight);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleGradientEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleGradientEx([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "topLeft")] [NativeName(NativeNameType.Type, "Color")] Color topLeft, [NativeName(NativeNameType.Param, "bottomLeft")] [NativeName(NativeNameType.Type, "Color")] Color bottomLeft, [NativeName(NativeNameType.Param, "topRight")] [NativeName(NativeNameType.Type, "Color")] Color topRight, [NativeName(NativeNameType.Param, "bottomRight")] [NativeName(NativeNameType.Type, "Color")] Color bottomRight)
		{
			DrawRectangleGradientExNative(rec, topLeft, bottomLeft, topRight, bottomRight);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleLinesNative([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, void>)funcTable[236])(posX, posY, width, height, color);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, Color, void>)funcTable[236])(posX, posY, width, height, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleLines([NativeName(NativeNameType.Param, "posX")] [NativeName(NativeNameType.Type, "int")] int posX, [NativeName(NativeNameType.Param, "posY")] [NativeName(NativeNameType.Type, "int")] int posY, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleLinesNative(posX, posY, width, height, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleLinesEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleLinesExNative([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "lineThick")] [NativeName(NativeNameType.Type, "float")] float lineThick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Rectangle, float, Color, void>)funcTable[237])(rec, lineThick, color);
			#else
			((delegate* unmanaged[Cdecl]<Rectangle, float, Color, void>)funcTable[237])(rec, lineThick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleLinesEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleLinesEx([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "lineThick")] [NativeName(NativeNameType.Type, "float")] float lineThick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleLinesExNative(rec, lineThick, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleRounded")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleRoundedNative([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "roundness")] [NativeName(NativeNameType.Type, "float")] float roundness, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Rectangle, float, int, Color, void>)funcTable[238])(rec, roundness, segments, color);
			#else
			((delegate* unmanaged[Cdecl]<Rectangle, float, int, Color, void>)funcTable[238])(rec, roundness, segments, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleRounded")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleRounded([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "roundness")] [NativeName(NativeNameType.Type, "float")] float roundness, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleRoundedNative(rec, roundness, segments, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleRoundedLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleRoundedLinesNative([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "roundness")] [NativeName(NativeNameType.Type, "float")] float roundness, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Rectangle, float, int, Color, void>)funcTable[239])(rec, roundness, segments, color);
			#else
			((delegate* unmanaged[Cdecl]<Rectangle, float, int, Color, void>)funcTable[239])(rec, roundness, segments, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleRoundedLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleRoundedLines([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "roundness")] [NativeName(NativeNameType.Type, "float")] float roundness, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleRoundedLinesNative(rec, roundness, segments, color);
		}

		[NativeName(NativeNameType.Func, "DrawRectangleRoundedLinesEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRectangleRoundedLinesExNative([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "roundness")] [NativeName(NativeNameType.Type, "float")] float roundness, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "lineThick")] [NativeName(NativeNameType.Type, "float")] float lineThick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Rectangle, float, int, float, Color, void>)funcTable[240])(rec, roundness, segments, lineThick, color);
			#else
			((delegate* unmanaged[Cdecl]<Rectangle, float, int, float, Color, void>)funcTable[240])(rec, roundness, segments, lineThick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawRectangleRoundedLinesEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawRectangleRoundedLinesEx([NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec, [NativeName(NativeNameType.Param, "roundness")] [NativeName(NativeNameType.Type, "float")] float roundness, [NativeName(NativeNameType.Param, "segments")] [NativeName(NativeNameType.Type, "int")] int segments, [NativeName(NativeNameType.Param, "lineThick")] [NativeName(NativeNameType.Type, "float")] float lineThick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawRectangleRoundedLinesExNative(rec, roundness, segments, lineThick, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangle")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTriangleNative([NativeName(NativeNameType.Param, "v1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v1, [NativeName(NativeNameType.Param, "v2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v2, [NativeName(NativeNameType.Param, "v3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v3, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Color, void>)funcTable[241])(v1, v2, v3, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Color, void>)funcTable[241])(v1, v2, v3, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawTriangle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangle([NativeName(NativeNameType.Param, "v1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v1, [NativeName(NativeNameType.Param, "v2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v2, [NativeName(NativeNameType.Param, "v3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v3, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawTriangleNative(v1, v2, v3, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangleLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTriangleLinesNative([NativeName(NativeNameType.Param, "v1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v1, [NativeName(NativeNameType.Param, "v2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v2, [NativeName(NativeNameType.Param, "v3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v3, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Color, void>)funcTable[242])(v1, v2, v3, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Color, void>)funcTable[242])(v1, v2, v3, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawTriangleLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleLines([NativeName(NativeNameType.Param, "v1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v1, [NativeName(NativeNameType.Param, "v2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v2, [NativeName(NativeNameType.Param, "v3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 v3, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawTriangleLinesNative(v1, v2, v3, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangleFan")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTriangleFanNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, int, Color, void>)funcTable[243])(points, pointCount, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, Color, void>)funcTable[243])((nint)points, pointCount, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawTriangleFan")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleFan([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawTriangleFanNative(points, pointCount, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangleFan")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleFan([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector2* ppoints = &points)
			{
				DrawTriangleFanNative((Vector2*)ppoints, pointCount, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTriangleStripNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, int, Color, void>)funcTable[244])(points, pointCount, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, Color, void>)funcTable[244])((nint)points, pointCount, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleStrip([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawTriangleStripNative(points, pointCount, color);
		}

		[NativeName(NativeNameType.Func, "DrawTriangleStrip")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawTriangleStrip([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector2* ppoints = &points)
			{
				DrawTriangleStripNative((Vector2*)ppoints, pointCount, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawPoly")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawPolyNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, int, float, float, Color, void>)funcTable[245])(center, sides, radius, rotation, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, int, float, float, Color, void>)funcTable[245])(center, sides, radius, rotation, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawPoly")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawPoly([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawPolyNative(center, sides, radius, rotation, color);
		}

		[NativeName(NativeNameType.Func, "DrawPolyLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawPolyLinesNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, int, float, float, Color, void>)funcTable[246])(center, sides, radius, rotation, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, int, float, float, Color, void>)funcTable[246])(center, sides, radius, rotation, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawPolyLines")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawPolyLines([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawPolyLinesNative(center, sides, radius, rotation, color);
		}

		[NativeName(NativeNameType.Func, "DrawPolyLinesEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawPolyLinesExNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "lineThick")] [NativeName(NativeNameType.Type, "float")] float lineThick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, int, float, float, float, Color, void>)funcTable[247])(center, sides, radius, rotation, lineThick, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, int, float, float, float, Color, void>)funcTable[247])(center, sides, radius, rotation, lineThick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawPolyLinesEx")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawPolyLinesEx([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "sides")] [NativeName(NativeNameType.Type, "int")] int sides, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "float")] float rotation, [NativeName(NativeNameType.Param, "lineThick")] [NativeName(NativeNameType.Type, "float")] float lineThick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawPolyLinesExNative(center, sides, radius, rotation, lineThick, color);
		}

		/// <summary>
		/// Splines drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawSplineLinear")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineLinearNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, int, float, Color, void>)funcTable[248])(points, pointCount, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, Color, void>)funcTable[248])((nint)points, pointCount, thick, color);
			#endif
		}

		/// <summary>
		/// Splines drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawSplineLinear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineLinear([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineLinearNative(points, pointCount, thick, color);
		}

		/// <summary>
		/// Splines drawing functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "DrawSplineLinear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineLinear([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector2* ppoints = &points)
			{
				DrawSplineLinearNative((Vector2*)ppoints, pointCount, thick, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawSplineBasis")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineBasisNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, int, float, Color, void>)funcTable[249])(points, pointCount, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, Color, void>)funcTable[249])((nint)points, pointCount, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineBasis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineBasis([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineBasisNative(points, pointCount, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawSplineBasis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineBasis([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector2* ppoints = &points)
			{
				DrawSplineBasisNative((Vector2*)ppoints, pointCount, thick, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawSplineCatmullRom")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineCatmullRomNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, int, float, Color, void>)funcTable[250])(points, pointCount, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, Color, void>)funcTable[250])((nint)points, pointCount, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineCatmullRom")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineCatmullRom([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineCatmullRomNative(points, pointCount, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawSplineCatmullRom")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineCatmullRom([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector2* ppoints = &points)
			{
				DrawSplineCatmullRomNative((Vector2*)ppoints, pointCount, thick, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawSplineBezierQuadratic")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineBezierQuadraticNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, int, float, Color, void>)funcTable[251])(points, pointCount, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, Color, void>)funcTable[251])((nint)points, pointCount, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineBezierQuadratic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineBezierQuadratic([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineBezierQuadraticNative(points, pointCount, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawSplineBezierQuadratic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineBezierQuadratic([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector2* ppoints = &points)
			{
				DrawSplineBezierQuadraticNative((Vector2*)ppoints, pointCount, thick, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawSplineBezierCubic")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineBezierCubicNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, int, float, Color, void>)funcTable[252])(points, pointCount, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, Color, void>)funcTable[252])((nint)points, pointCount, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineBezierCubic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineBezierCubic([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineBezierCubicNative(points, pointCount, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawSplineBezierCubic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineBezierCubic([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			fixed (Vector2* ppoints = &points)
			{
				DrawSplineBezierCubicNative((Vector2*)ppoints, pointCount, thick, color);
			}
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentLinear")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineSegmentLinearNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, Color, void>)funcTable[253])(p1, p2, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, Color, void>)funcTable[253])(p1, p2, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentLinear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineSegmentLinear([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineSegmentLinearNative(p1, p2, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentBasis")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineSegmentBasisNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Color, void>)funcTable[254])(p1, p2, p3, p4, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Color, void>)funcTable[254])(p1, p2, p3, p4, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentBasis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineSegmentBasis([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineSegmentBasisNative(p1, p2, p3, p4, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentCatmullRom")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineSegmentCatmullRomNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Color, void>)funcTable[255])(p1, p2, p3, p4, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Color, void>)funcTable[255])(p1, p2, p3, p4, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentCatmullRom")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineSegmentCatmullRom([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineSegmentCatmullRomNative(p1, p2, p3, p4, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentBezierQuadratic")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineSegmentBezierQuadraticNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "c2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, float, Color, void>)funcTable[256])(p1, c2, p3, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, float, Color, void>)funcTable[256])(p1, c2, p3, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentBezierQuadratic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineSegmentBezierQuadratic([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "c2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineSegmentBezierQuadraticNative(p1, c2, p3, thick, color);
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentBezierCubic")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawSplineSegmentBezierCubicNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "c2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c2, [NativeName(NativeNameType.Param, "c3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Color, void>)funcTable[257])(p1, c2, c3, p4, thick, color);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Color, void>)funcTable[257])(p1, c2, c3, p4, thick, color);
			#endif
		}

		[NativeName(NativeNameType.Func, "DrawSplineSegmentBezierCubic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawSplineSegmentBezierCubic([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "c2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c2, [NativeName(NativeNameType.Param, "c3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "thick")] [NativeName(NativeNameType.Type, "float")] float thick, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			DrawSplineSegmentBezierCubicNative(p1, c2, c3, p4, thick, color);
		}

		/// <summary>
		/// Spline segment point evaluation functions, for a given t [0.0f .. 1.0f]<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "GetSplinePointLinear")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetSplinePointLinearNative([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, Vector2>)funcTable[258])(startPos, endPos, t);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, Vector2>)funcTable[258])(startPos, endPos, t);
			#endif
		}

		/// <summary>
		/// Spline segment point evaluation functions, for a given t [0.0f .. 1.0f]<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "GetSplinePointLinear")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetSplinePointLinear([NativeName(NativeNameType.Param, "startPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos, [NativeName(NativeNameType.Param, "endPos")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			Vector2 ret = GetSplinePointLinearNative(startPos, endPos, t);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetSplinePointBasis")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetSplinePointBasisNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Vector2>)funcTable[259])(p1, p2, p3, p4, t);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Vector2>)funcTable[259])(p1, p2, p3, p4, t);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetSplinePointBasis")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetSplinePointBasis([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			Vector2 ret = GetSplinePointBasisNative(p1, p2, p3, p4, t);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetSplinePointCatmullRom")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetSplinePointCatmullRomNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Vector2>)funcTable[260])(p1, p2, p3, p4, t);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Vector2>)funcTable[260])(p1, p2, p3, p4, t);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetSplinePointCatmullRom")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetSplinePointCatmullRom([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			Vector2 ret = GetSplinePointCatmullRomNative(p1, p2, p3, p4, t);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetSplinePointBezierQuad")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetSplinePointBezierQuadNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "c2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, float, Vector2>)funcTable[261])(p1, c2, p3, t);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, float, Vector2>)funcTable[261])(p1, c2, p3, t);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetSplinePointBezierQuad")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetSplinePointBezierQuad([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "c2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			Vector2 ret = GetSplinePointBezierQuadNative(p1, c2, p3, t);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetSplinePointBezierCubic")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetSplinePointBezierCubicNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "c2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c2, [NativeName(NativeNameType.Param, "c3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Vector2>)funcTable[262])(p1, c2, c3, p4, t);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float, Vector2>)funcTable[262])(p1, c2, c3, p4, t);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetSplinePointBezierCubic")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetSplinePointBezierCubic([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "c2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c2, [NativeName(NativeNameType.Param, "c3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 c3, [NativeName(NativeNameType.Param, "p4")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p4, [NativeName(NativeNameType.Param, "t")] [NativeName(NativeNameType.Type, "float")] float t)
		{
			Vector2 ret = GetSplinePointBezierCubicNative(p1, c2, c3, p4, t);
			return ret;
		}

		/// <summary>
		/// Basic shapes collision detection functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CheckCollisionRecs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionRecsNative([NativeName(NativeNameType.Param, "rec1")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec1, [NativeName(NativeNameType.Param, "rec2")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Rectangle, Rectangle, byte>)funcTable[263])(rec1, rec2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Rectangle, Rectangle, byte>)funcTable[263])(rec1, rec2);
			#endif
		}

		/// <summary>
		/// Basic shapes collision detection functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "CheckCollisionRecs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionRecs([NativeName(NativeNameType.Param, "rec1")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec1, [NativeName(NativeNameType.Param, "rec2")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec2)
		{
			byte ret = CheckCollisionRecsNative(rec1, rec2);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionCircles")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionCirclesNative([NativeName(NativeNameType.Param, "center1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center1, [NativeName(NativeNameType.Param, "radius1")] [NativeName(NativeNameType.Type, "float")] float radius1, [NativeName(NativeNameType.Param, "center2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center2, [NativeName(NativeNameType.Param, "radius2")] [NativeName(NativeNameType.Type, "float")] float radius2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, float, Vector2, float, byte>)funcTable[264])(center1, radius1, center2, radius2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, float, Vector2, float, byte>)funcTable[264])(center1, radius1, center2, radius2);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionCircles")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionCircles([NativeName(NativeNameType.Param, "center1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center1, [NativeName(NativeNameType.Param, "radius1")] [NativeName(NativeNameType.Type, "float")] float radius1, [NativeName(NativeNameType.Param, "center2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center2, [NativeName(NativeNameType.Param, "radius2")] [NativeName(NativeNameType.Type, "float")] float radius2)
		{
			byte ret = CheckCollisionCirclesNative(center1, radius1, center2, radius2);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionCircleRec")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionCircleRecNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, float, Rectangle, byte>)funcTable[265])(center, radius, rec);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, float, Rectangle, byte>)funcTable[265])(center, radius, rec);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionCircleRec")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionCircleRec([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec)
		{
			byte ret = CheckCollisionCircleRecNative(center, radius, rec);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionCircleLine")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionCircleLineNative([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, float, Vector2, Vector2, byte>)funcTable[266])(center, radius, p1, p2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, float, Vector2, Vector2, byte>)funcTable[266])(center, radius, p1, p2);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionCircleLine")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionCircleLine([NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2)
		{
			byte ret = CheckCollisionCircleLineNative(center, radius, p1, p2);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointRec")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionPointRecNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Rectangle, byte>)funcTable[267])(point, rec);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Rectangle, byte>)funcTable[267])(point, rec);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointRec")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionPointRec([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "rec")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec)
		{
			byte ret = CheckCollisionPointRecNative(point, rec);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointCircle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionPointCircleNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, byte>)funcTable[268])(point, center, radius);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, float, byte>)funcTable[268])(point, center, radius);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointCircle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionPointCircle([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 center, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			byte ret = CheckCollisionPointCircleNative(point, center, radius);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointTriangle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionPointTriangleNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, byte>)funcTable[269])(point, p1, p2, p3);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, byte>)funcTable[269])(point, p1, p2, p3);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointTriangle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionPointTriangle([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "p3")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p3)
		{
			byte ret = CheckCollisionPointTriangleNative(point, p1, p2, p3);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointLine")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionPointLineNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "threshold")] [NativeName(NativeNameType.Type, "int")] int threshold)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, int, byte>)funcTable[270])(point, p1, p2, threshold);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, int, byte>)funcTable[270])(point, p1, p2, threshold);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointLine")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionPointLine([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 p2, [NativeName(NativeNameType.Param, "threshold")] [NativeName(NativeNameType.Type, "int")] int threshold)
		{
			byte ret = CheckCollisionPointLineNative(point, p1, p2, threshold);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointPoly")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionPointPolyNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2*, int, byte>)funcTable[271])(point, points, pointCount);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, nint, int, byte>)funcTable[271])(point, (nint)points, pointCount);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointPoly")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionPointPoly([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] Vector2* points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount)
		{
			byte ret = CheckCollisionPointPolyNative(point, points, pointCount);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionPointPoly")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionPointPoly([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 point, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "Vector2 const *")] ref Vector2 points, [NativeName(NativeNameType.Param, "pointCount")] [NativeName(NativeNameType.Type, "int")] int pointCount)
		{
			fixed (Vector2* ppoints = &points)
			{
				byte ret = CheckCollisionPointPolyNative(point, (Vector2*)ppoints, pointCount);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "CheckCollisionLines")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CheckCollisionLinesNative([NativeName(NativeNameType.Param, "startPos1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos1, [NativeName(NativeNameType.Param, "endPos1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos1, [NativeName(NativeNameType.Param, "startPos2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos2, [NativeName(NativeNameType.Param, "endPos2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos2, [NativeName(NativeNameType.Param, "collisionPoint")] [NativeName(NativeNameType.Type, "Vector2 *")] Vector2* collisionPoint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, Vector2*, byte>)funcTable[272])(startPos1, endPos1, startPos2, endPos2, collisionPoint);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, nint, byte>)funcTable[272])(startPos1, endPos1, startPos2, endPos2, (nint)collisionPoint);
			#endif
		}

		[NativeName(NativeNameType.Func, "CheckCollisionLines")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionLines([NativeName(NativeNameType.Param, "startPos1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos1, [NativeName(NativeNameType.Param, "endPos1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos1, [NativeName(NativeNameType.Param, "startPos2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos2, [NativeName(NativeNameType.Param, "endPos2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos2, [NativeName(NativeNameType.Param, "collisionPoint")] [NativeName(NativeNameType.Type, "Vector2 *")] Vector2* collisionPoint)
		{
			byte ret = CheckCollisionLinesNative(startPos1, endPos1, startPos2, endPos2, collisionPoint);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "CheckCollisionLines")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CheckCollisionLines([NativeName(NativeNameType.Param, "startPos1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos1, [NativeName(NativeNameType.Param, "endPos1")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos1, [NativeName(NativeNameType.Param, "startPos2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 startPos2, [NativeName(NativeNameType.Param, "endPos2")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 endPos2, [NativeName(NativeNameType.Param, "collisionPoint")] [NativeName(NativeNameType.Type, "Vector2 *")] ref Vector2 collisionPoint)
		{
			fixed (Vector2* pcollisionPoint = &collisionPoint)
			{
				byte ret = CheckCollisionLinesNative(startPos1, endPos1, startPos2, endPos2, (Vector2*)pcollisionPoint);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "GetCollisionRec")]
		[return: NativeName(NativeNameType.Type, "Rectangle")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Rectangle GetCollisionRecNative([NativeName(NativeNameType.Param, "rec1")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec1, [NativeName(NativeNameType.Param, "rec2")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Rectangle, Rectangle, Rectangle>)funcTable[273])(rec1, rec2);
			#else
			return (Rectangle)((delegate* unmanaged[Cdecl]<Rectangle, Rectangle, Rectangle>)funcTable[273])(rec1, rec2);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCollisionRec")]
		[return: NativeName(NativeNameType.Type, "Rectangle")]
		public static Rectangle GetCollisionRec([NativeName(NativeNameType.Param, "rec1")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec1, [NativeName(NativeNameType.Param, "rec2")] [NativeName(NativeNameType.Type, "Rectangle")] Rectangle rec2)
		{
			Rectangle ret = GetCollisionRecNative(rec1, rec2);
			return ret;
		}

		/// <summary>
		/// Image loading functions<br/>
		/// NOTE: These functions do not require GPU access<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadImage")]
		[return: NativeName(NativeNameType.Type, "Image")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Image LoadImageNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Image>)funcTable[274])(fileName);
			#else
			return (Image)((delegate* unmanaged[Cdecl]<nint, Image>)funcTable[274])((nint)fileName);
			#endif
		}

		/// <summary>
		/// Image loading functions<br/>
		/// NOTE: These functions do not require GPU access<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadImage")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImage([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			Image ret = LoadImageNative(fileName);
			return ret;
		}

		/// <summary>
		/// Image loading functions<br/>
		/// NOTE: These functions do not require GPU access<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadImage")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImage([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				Image ret = LoadImageNative((byte*)pfileName);
				return ret;
			}
		}

		/// <summary>
		/// Image loading functions<br/>
		/// NOTE: These functions do not require GPU access<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadImage")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImage([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				Image ret = LoadImageNative((byte*)pfileName);
				return ret;
			}
		}

		/// <summary>
		/// Image loading functions<br/>
		/// NOTE: These functions do not require GPU access<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadImage")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImage([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Image ret = LoadImageNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageRaw")]
		[return: NativeName(NativeNameType.Type, "Image")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Image LoadImageRawNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "int")] int format, [NativeName(NativeNameType.Param, "headerSize")] [NativeName(NativeNameType.Type, "int")] int headerSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int, int, int, Image>)funcTable[275])(fileName, width, height, format, headerSize);
			#else
			return (Image)((delegate* unmanaged[Cdecl]<nint, int, int, int, int, Image>)funcTable[275])((nint)fileName, width, height, format, headerSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadImageRaw")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageRaw([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "int")] int format, [NativeName(NativeNameType.Param, "headerSize")] [NativeName(NativeNameType.Type, "int")] int headerSize)
		{
			Image ret = LoadImageRawNative(fileName, width, height, format, headerSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageRaw")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageRaw([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "int")] int format, [NativeName(NativeNameType.Param, "headerSize")] [NativeName(NativeNameType.Type, "int")] int headerSize)
		{
			fixed (byte* pfileName = &fileName)
			{
				Image ret = LoadImageRawNative((byte*)pfileName, width, height, format, headerSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageRaw")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageRaw([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "int")] int format, [NativeName(NativeNameType.Param, "headerSize")] [NativeName(NativeNameType.Type, "int")] int headerSize)
		{
			fixed (byte* pfileName = fileName)
			{
				Image ret = LoadImageRawNative((byte*)pfileName, width, height, format, headerSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageRaw")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageRaw([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "int")] int format, [NativeName(NativeNameType.Param, "headerSize")] [NativeName(NativeNameType.Type, "int")] int headerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Image ret = LoadImageRawNative(pStr0, width, height, format, headerSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Image LoadImageAnimNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, Image>)funcTable[276])(fileName, frames);
			#else
			return (Image)((delegate* unmanaged[Cdecl]<nint, nint, Image>)funcTable[276])((nint)fileName, (nint)frames);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnim([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			Image ret = LoadImageAnimNative(fileName, frames);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnim([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			fixed (byte* pfileName = &fileName)
			{
				Image ret = LoadImageAnimNative((byte*)pfileName, frames);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnim([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			fixed (byte* pfileName = fileName)
			{
				Image ret = LoadImageAnimNative((byte*)pfileName, frames);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnim([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Image ret = LoadImageAnimNative(pStr0, frames);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnim([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (int* pframes = &frames)
			{
				Image ret = LoadImageAnimNative(fileName, (int*)pframes);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnim([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (byte* pfileName = &fileName)
			{
				fixed (int* pframes = &frames)
				{
					Image ret = LoadImageAnimNative((byte*)pfileName, (int*)pframes);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnim([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (byte* pfileName = fileName)
			{
				fixed (int* pframes = &frames)
				{
					Image ret = LoadImageAnimNative((byte*)pfileName, (int*)pframes);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnim")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnim([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pframes = &frames)
			{
				Image ret = LoadImageAnimNative(pStr0, (int*)pframes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Image LoadImageAnimFromMemoryNative([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] byte* fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, int*, Image>)funcTable[277])(fileType, fileData, dataSize, frames);
			#else
			return (Image)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, Image>)funcTable[277])((nint)fileType, (nint)fileData, dataSize, (nint)frames);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] byte* fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			Image ret = LoadImageAnimFromMemoryNative(fileType, fileData, dataSize, frames);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			fixed (byte* pfileType = &fileType)
			{
				Image ret = LoadImageAnimFromMemoryNative((byte*)pfileType, fileData, dataSize, frames);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			fixed (byte* pfileType = fileType)
			{
				Image ret = LoadImageAnimFromMemoryNative((byte*)pfileType, fileData, dataSize, frames);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] string fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Image ret = LoadImageAnimFromMemoryNative(pStr0, fileData, dataSize, frames);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] byte* fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			fixed (byte* pfileData = &fileData)
			{
				Image ret = LoadImageAnimFromMemoryNative(fileType, (byte*)pfileData, dataSize, frames);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			fixed (byte* pfileType = &fileType)
			{
				fixed (byte* pfileData = &fileData)
				{
					Image ret = LoadImageAnimFromMemoryNative((byte*)pfileType, (byte*)pfileData, dataSize, frames);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			fixed (byte* pfileType = fileType)
			{
				fixed (byte* pfileData = &fileData)
				{
					Image ret = LoadImageAnimFromMemoryNative((byte*)pfileType, (byte*)pfileData, dataSize, frames);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] string fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] int* frames)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfileData = &fileData)
			{
				Image ret = LoadImageAnimFromMemoryNative(pStr0, (byte*)pfileData, dataSize, frames);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] byte* fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (int* pframes = &frames)
			{
				Image ret = LoadImageAnimFromMemoryNative(fileType, fileData, dataSize, (int*)pframes);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (byte* pfileType = &fileType)
			{
				fixed (int* pframes = &frames)
				{
					Image ret = LoadImageAnimFromMemoryNative((byte*)pfileType, fileData, dataSize, (int*)pframes);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (byte* pfileType = fileType)
			{
				fixed (int* pframes = &frames)
				{
					Image ret = LoadImageAnimFromMemoryNative((byte*)pfileType, fileData, dataSize, (int*)pframes);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] string fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pframes = &frames)
			{
				Image ret = LoadImageAnimFromMemoryNative(pStr0, fileData, dataSize, (int*)pframes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] byte* fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (byte* pfileData = &fileData)
			{
				fixed (int* pframes = &frames)
				{
					Image ret = LoadImageAnimFromMemoryNative(fileType, (byte*)pfileData, dataSize, (int*)pframes);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (byte* pfileType = &fileType)
			{
				fixed (byte* pfileData = &fileData)
				{
					fixed (int* pframes = &frames)
					{
						Image ret = LoadImageAnimFromMemoryNative((byte*)pfileType, (byte*)pfileData, dataSize, (int*)pframes);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			fixed (byte* pfileType = fileType)
			{
				fixed (byte* pfileData = &fileData)
				{
					fixed (int* pframes = &frames)
					{
						Image ret = LoadImageAnimFromMemoryNative((byte*)pfileType, (byte*)pfileData, dataSize, (int*)pframes);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageAnimFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageAnimFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] string fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "frames")] [NativeName(NativeNameType.Type, "int *")] ref int frames)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfileData = &fileData)
			{
				fixed (int* pframes = &frames)
				{
					Image ret = LoadImageAnimFromMemoryNative(pStr0, (byte*)pfileData, dataSize, (int*)pframes);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Image LoadImageFromMemoryNative([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] byte* fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, Image>)funcTable[278])(fileType, fileData, dataSize);
			#else
			return (Image)((delegate* unmanaged[Cdecl]<nint, nint, int, Image>)funcTable[278])((nint)fileType, (nint)fileData, dataSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] byte* fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			Image ret = LoadImageFromMemoryNative(fileType, fileData, dataSize);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pfileType = &fileType)
			{
				Image ret = LoadImageFromMemoryNative((byte*)pfileType, fileData, dataSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pfileType = fileType)
			{
				Image ret = LoadImageFromMemoryNative((byte*)pfileType, fileData, dataSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] string fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Image ret = LoadImageFromMemoryNative(pStr0, fileData, dataSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] byte* fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pfileData = &fileData)
			{
				Image ret = LoadImageFromMemoryNative(fileType, (byte*)pfileData, dataSize);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pfileType = &fileType)
			{
				fixed (byte* pfileData = &fileData)
				{
					Image ret = LoadImageFromMemoryNative((byte*)pfileType, (byte*)pfileData, dataSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pfileType = fileType)
			{
				fixed (byte* pfileData = &fileData)
				{
					Image ret = LoadImageFromMemoryNative((byte*)pfileType, (byte*)pfileData, dataSize);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageFromMemory")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image LoadImageFromMemory([NativeName(NativeNameType.Param, "fileType")] [NativeName(NativeNameType.Type, "char const *")] string fileType, [NativeName(NativeNameType.Param, "fileData")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte fileData, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileType != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileType);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileType, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfileData = &fileData)
			{
				Image ret = LoadImageFromMemoryNative(pStr0, (byte*)pfileData, dataSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadImageFromTexture")]
		[return: NativeName(NativeNameType.Type, "Image")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Image LoadImageFromTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Texture, Image>)funcTable[279])(texture);
			#else
			return (Image)((delegate* unmanaged[Cdecl]<Texture, Image>)funcTable[279])(texture);
			#endif
		}
	}
}
