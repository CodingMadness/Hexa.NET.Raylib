// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Raylib
{
	public unsafe partial class Raylib
	{
		/// <summary>
		/// Window-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "InitWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InitWindowNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] byte* title)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte*, void>)funcTable[0])(width, height, title);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[0])(width, height, (nint)title);
			#endif
		}

		/// <summary>
		/// Window-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "InitWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InitWindow([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] byte* title)
		{
			InitWindowNative(width, height, title);
		}

		/// <summary>
		/// Window-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "InitWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InitWindow([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] ref byte title)
		{
			fixed (byte* ptitle = &title)
			{
				InitWindowNative(width, height, (byte*)ptitle);
			}
		}

		/// <summary>
		/// Window-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "InitWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InitWindow([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> title)
		{
			fixed (byte* ptitle = title)
			{
				InitWindowNative(width, height, (byte*)ptitle);
			}
		}

		/// <summary>
		/// Window-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "InitWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InitWindow([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InitWindowNative(width, height, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "CloseWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseWindowNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1])();
			#endif
		}

		[NativeName(NativeNameType.Func, "CloseWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseWindow()
		{
			CloseWindowNative();
		}

		[NativeName(NativeNameType.Func, "WindowShouldClose")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowShouldCloseNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[2])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[2])();
			#endif
		}

		[NativeName(NativeNameType.Func, "WindowShouldClose")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowShouldClose()
		{
			byte ret = WindowShouldCloseNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsWindowReady")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowReadyNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[3])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[3])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsWindowReady")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWindowReady()
		{
			byte ret = IsWindowReadyNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowFullscreenNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[4])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[4])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWindowFullscreen()
		{
			byte ret = IsWindowFullscreenNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsWindowHidden")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowHiddenNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[5])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[5])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsWindowHidden")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWindowHidden()
		{
			byte ret = IsWindowHiddenNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsWindowMinimized")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowMinimizedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[6])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[6])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsWindowMinimized")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWindowMinimized()
		{
			byte ret = IsWindowMinimizedNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsWindowMaximized")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowMaximizedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[7])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[7])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsWindowMaximized")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWindowMaximized()
		{
			byte ret = IsWindowMaximizedNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsWindowFocused")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowFocusedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[8])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[8])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsWindowFocused")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWindowFocused()
		{
			byte ret = IsWindowFocusedNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsWindowResized")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowResizedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[9])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[9])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsWindowResized")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWindowResized()
		{
			byte ret = IsWindowResizedNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsWindowState")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowStateNative([NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "unsigned int")] uint flag)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[10])(flag);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[10])(flag);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsWindowState")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWindowState([NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "unsigned int")] uint flag)
		{
			byte ret = IsWindowStateNative(flag);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SetWindowState")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowStateNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "unsigned int")] uint flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[11])(flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[11])(flags);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowState([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "unsigned int")] uint flags)
		{
			SetWindowStateNative(flags);
		}

		[NativeName(NativeNameType.Func, "ClearWindowState")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearWindowStateNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "unsigned int")] uint flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[12])(flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[12])(flags);
			#endif
		}

		[NativeName(NativeNameType.Func, "ClearWindowState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ClearWindowState([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "unsigned int")] uint flags)
		{
			ClearWindowStateNative(flags);
		}

		[NativeName(NativeNameType.Func, "ToggleFullscreen")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ToggleFullscreenNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[13])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[13])();
			#endif
		}

		[NativeName(NativeNameType.Func, "ToggleFullscreen")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ToggleFullscreen()
		{
			ToggleFullscreenNative();
		}

		[NativeName(NativeNameType.Func, "ToggleBorderlessWindowed")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ToggleBorderlessWindowedNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[14])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[14])();
			#endif
		}

		[NativeName(NativeNameType.Func, "ToggleBorderlessWindowed")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ToggleBorderlessWindowed()
		{
			ToggleBorderlessWindowedNative();
		}

		[NativeName(NativeNameType.Func, "MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaximizeWindowNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[15])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[15])();
			#endif
		}

		[NativeName(NativeNameType.Func, "MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MaximizeWindow()
		{
			MaximizeWindowNative();
		}

		[NativeName(NativeNameType.Func, "MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MinimizeWindowNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[16])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[16])();
			#endif
		}

		[NativeName(NativeNameType.Func, "MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MinimizeWindow()
		{
			MinimizeWindowNative();
		}

		[NativeName(NativeNameType.Func, "RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RestoreWindowNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[17])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[17])();
			#endif
		}

		[NativeName(NativeNameType.Func, "RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RestoreWindow()
		{
			RestoreWindowNative();
		}

		[NativeName(NativeNameType.Func, "SetWindowIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowIconNative([NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "Image")] Image image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Image, void>)funcTable[18])(image);
			#else
			((delegate* unmanaged[Cdecl]<Image, void>)funcTable[18])(image);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowIcon([NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "Image")] Image image)
		{
			SetWindowIconNative(image);
		}

		[NativeName(NativeNameType.Func, "SetWindowIcons")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowIconsNative([NativeName(NativeNameType.Param, "images")] [NativeName(NativeNameType.Type, "Image *")] Image* images, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Image*, int, void>)funcTable[19])(images, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[19])((nint)images, count);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowIcons")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowIcons([NativeName(NativeNameType.Param, "images")] [NativeName(NativeNameType.Type, "Image *")] Image* images, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			SetWindowIconsNative(images, count);
		}

		[NativeName(NativeNameType.Func, "SetWindowIcons")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowIcons([NativeName(NativeNameType.Param, "images")] [NativeName(NativeNameType.Type, "Image *")] ref Image images, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (Image* pimages = &images)
			{
				SetWindowIconsNative((Image*)pimages, count);
			}
		}

		[NativeName(NativeNameType.Func, "SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowTitleNative([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] byte* title)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[20])(title);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[20])((nint)title);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowTitle([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] byte* title)
		{
			SetWindowTitleNative(title);
		}

		[NativeName(NativeNameType.Func, "SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowTitle([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] ref byte title)
		{
			fixed (byte* ptitle = &title)
			{
				SetWindowTitleNative((byte*)ptitle);
			}
		}

		[NativeName(NativeNameType.Func, "SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowTitle([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> title)
		{
			fixed (byte* ptitle = title)
			{
				SetWindowTitleNative((byte*)ptitle);
			}
		}

		[NativeName(NativeNameType.Func, "SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowTitle([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "char const *")] string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowTitleNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "SetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowPositionNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[21])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[21])(x, y);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowPosition([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			SetWindowPositionNative(x, y);
		}

		[NativeName(NativeNameType.Func, "SetWindowMonitor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMonitorNative([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[22])(monitor);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[22])(monitor);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowMonitor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowMonitor([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			SetWindowMonitorNative(monitor);
		}

		[NativeName(NativeNameType.Func, "SetWindowMinSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMinSizeNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[23])(width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[23])(width, height);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowMinSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowMinSize([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			SetWindowMinSizeNative(width, height);
		}

		[NativeName(NativeNameType.Func, "SetWindowMaxSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowMaxSizeNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[24])(width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[24])(width, height);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowMaxSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowMaxSize([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			SetWindowMaxSizeNative(width, height);
		}

		[NativeName(NativeNameType.Func, "SetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowSizeNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[25])(width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[25])(width, height);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowSize([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			SetWindowSizeNative(width, height);
		}

		[NativeName(NativeNameType.Func, "SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowOpacityNative([NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[26])(opacity);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[26])(opacity);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowOpacity([NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			SetWindowOpacityNative(opacity);
		}

		[NativeName(NativeNameType.Func, "SetWindowFocused")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowFocusedNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[27])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[27])();
			#endif
		}

		[NativeName(NativeNameType.Func, "SetWindowFocused")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWindowFocused()
		{
			SetWindowFocusedNative();
		}

		[NativeName(NativeNameType.Func, "GetWindowHandle")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetWindowHandleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*>)funcTable[28])();
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint>)funcTable[28])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetWindowHandle")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetWindowHandle()
		{
			void* ret = GetWindowHandleNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetScreenWidth")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetScreenWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[29])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[29])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetScreenWidth")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetScreenWidth()
		{
			int ret = GetScreenWidthNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetScreenHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetScreenHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[30])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[30])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetScreenHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetScreenHeight()
		{
			int ret = GetScreenHeightNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetRenderWidth")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRenderWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[31])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[31])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetRenderWidth")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRenderWidth()
		{
			int ret = GetRenderWidthNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetRenderHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRenderHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[32])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[32])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetRenderHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRenderHeight()
		{
			int ret = GetRenderHeightNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMonitorCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[33])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[33])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMonitorCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMonitorCount()
		{
			int ret = GetMonitorCountNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCurrentMonitor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCurrentMonitorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[34])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[34])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCurrentMonitor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetCurrentMonitor()
		{
			int ret = GetCurrentMonitorNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorPosition")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetMonitorPositionNative([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, Vector2>)funcTable[35])(monitor);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<int, Vector2>)funcTable[35])(monitor);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMonitorPosition")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetMonitorPosition([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			Vector2 ret = GetMonitorPositionNative(monitor);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorWidth")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMonitorWidthNative([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[36])(monitor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[36])(monitor);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMonitorWidth")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMonitorWidth([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			int ret = GetMonitorWidthNative(monitor);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMonitorHeightNative([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[37])(monitor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[37])(monitor);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMonitorHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMonitorHeight([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			int ret = GetMonitorHeightNative(monitor);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorPhysicalWidth")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMonitorPhysicalWidthNative([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[38])(monitor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[38])(monitor);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMonitorPhysicalWidth")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMonitorPhysicalWidth([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			int ret = GetMonitorPhysicalWidthNative(monitor);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorPhysicalHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMonitorPhysicalHeightNative([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[39])(monitor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[39])(monitor);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMonitorPhysicalHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMonitorPhysicalHeight([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			int ret = GetMonitorPhysicalHeightNative(monitor);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorRefreshRate")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMonitorRefreshRateNative([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[40])(monitor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[40])(monitor);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMonitorRefreshRate")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMonitorRefreshRate([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			int ret = GetMonitorRefreshRateNative(monitor);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetWindowPositionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2>)funcTable[41])();
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2>)funcTable[41])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetWindowPosition()
		{
			Vector2 ret = GetWindowPositionNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetWindowScaleDPI")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetWindowScaleDPINative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2>)funcTable[42])();
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2>)funcTable[42])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetWindowScaleDPI")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetWindowScaleDPI()
		{
			Vector2 ret = GetWindowScaleDPINative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetMonitorNameNative([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[43])(monitor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[43])(monitor);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetMonitorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetMonitorName([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			byte* ret = GetMonitorNameNative(monitor);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetMonitorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetMonitorNameS([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "int")] int monitor)
		{
			string ret = Utils.DecodeStringUTF8(GetMonitorNameNative(monitor));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetClipboardTextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[44])(text);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[44])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			SetClipboardTextNative(text);
		}

		[NativeName(NativeNameType.Func, "SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				SetClipboardTextNative((byte*)ptext);
			}
		}

		[NativeName(NativeNameType.Func, "SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				SetClipboardTextNative((byte*)ptext);
			}
		}

		[NativeName(NativeNameType.Func, "SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetClipboardTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[45])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[45])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetClipboardText()
		{
			byte* ret = GetClipboardTextNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardTextNative());
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetClipboardImage")]
		[return: NativeName(NativeNameType.Type, "Image")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Image GetClipboardImageNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Image>)funcTable[46])();
			#else
			return (Image)((delegate* unmanaged[Cdecl]<Image>)funcTable[46])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetClipboardImage")]
		[return: NativeName(NativeNameType.Type, "Image")]
		public static Image GetClipboardImage()
		{
			Image ret = GetClipboardImageNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "EnableEventWaiting")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableEventWaitingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[47])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[47])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EnableEventWaiting")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EnableEventWaiting()
		{
			EnableEventWaitingNative();
		}

		[NativeName(NativeNameType.Func, "DisableEventWaiting")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableEventWaitingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[48])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[48])();
			#endif
		}

		[NativeName(NativeNameType.Func, "DisableEventWaiting")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DisableEventWaiting()
		{
			DisableEventWaitingNative();
		}

		/// <summary>
		/// Cursor-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "ShowCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowCursorNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[49])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[49])();
			#endif
		}

		/// <summary>
		/// Cursor-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "ShowCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowCursor()
		{
			ShowCursorNative();
		}

		[NativeName(NativeNameType.Func, "HideCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HideCursorNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[50])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[50])();
			#endif
		}

		[NativeName(NativeNameType.Func, "HideCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HideCursor()
		{
			HideCursorNative();
		}

		[NativeName(NativeNameType.Func, "IsCursorHidden")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsCursorHiddenNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[51])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[51])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsCursorHidden")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsCursorHidden()
		{
			byte ret = IsCursorHiddenNative();
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "EnableCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableCursorNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[52])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[52])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EnableCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EnableCursor()
		{
			EnableCursorNative();
		}

		[NativeName(NativeNameType.Func, "DisableCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableCursorNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[53])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[53])();
			#endif
		}

		[NativeName(NativeNameType.Func, "DisableCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DisableCursor()
		{
			DisableCursorNative();
		}

		[NativeName(NativeNameType.Func, "IsCursorOnScreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsCursorOnScreenNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[54])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[54])();
			#endif
		}

		[NativeName(NativeNameType.Func, "IsCursorOnScreen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsCursorOnScreen()
		{
			byte ret = IsCursorOnScreenNative();
			return ret != 0;
		}

		/// <summary>
		/// Drawing-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "ClearBackground")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBackgroundNative([NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Color, void>)funcTable[55])(color);
			#else
			((delegate* unmanaged[Cdecl]<Color, void>)funcTable[55])(color);
			#endif
		}

		/// <summary>
		/// Drawing-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "ClearBackground")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ClearBackground([NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Color")] Color color)
		{
			ClearBackgroundNative(color);
		}

		[NativeName(NativeNameType.Func, "BeginDrawing")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginDrawingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[56])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[56])();
			#endif
		}

		[NativeName(NativeNameType.Func, "BeginDrawing")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginDrawing()
		{
			BeginDrawingNative();
		}

		[NativeName(NativeNameType.Func, "EndDrawing")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndDrawingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[57])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[57])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EndDrawing")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndDrawing()
		{
			EndDrawingNative();
		}

		[NativeName(NativeNameType.Func, "BeginMode2D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginMode2DNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera2D")] Camera2D camera)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Camera2D, void>)funcTable[58])(camera);
			#else
			((delegate* unmanaged[Cdecl]<Camera2D, void>)funcTable[58])(camera);
			#endif
		}

		[NativeName(NativeNameType.Func, "BeginMode2D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginMode2D([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera2D")] Camera2D camera)
		{
			BeginMode2DNative(camera);
		}

		[NativeName(NativeNameType.Func, "EndMode2D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndMode2DNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[59])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[59])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EndMode2D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndMode2D()
		{
			EndMode2DNative();
		}

		[NativeName(NativeNameType.Func, "BeginMode3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginMode3DNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera3D")] Camera3D camera)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Camera3D, void>)funcTable[60])(camera);
			#else
			((delegate* unmanaged[Cdecl]<Camera3D, void>)funcTable[60])(camera);
			#endif
		}

		[NativeName(NativeNameType.Func, "BeginMode3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginMode3D([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera3D")] Camera3D camera)
		{
			BeginMode3DNative(camera);
		}

		[NativeName(NativeNameType.Func, "EndMode3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndMode3DNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[61])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[61])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EndMode3D")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndMode3D()
		{
			EndMode3DNative();
		}

		[NativeName(NativeNameType.Func, "BeginTextureMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginTextureModeNative([NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "RenderTexture2D")] RenderTexture target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<RenderTexture, void>)funcTable[62])(target);
			#else
			((delegate* unmanaged[Cdecl]<RenderTexture, void>)funcTable[62])(target);
			#endif
		}

		[NativeName(NativeNameType.Func, "BeginTextureMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginTextureMode([NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "RenderTexture2D")] RenderTexture target)
		{
			BeginTextureModeNative(target);
		}

		[NativeName(NativeNameType.Func, "EndTextureMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndTextureModeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[63])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[63])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EndTextureMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndTextureMode()
		{
			EndTextureModeNative();
		}

		[NativeName(NativeNameType.Func, "BeginShaderMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginShaderModeNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Shader, void>)funcTable[64])(shader);
			#else
			((delegate* unmanaged[Cdecl]<Shader, void>)funcTable[64])(shader);
			#endif
		}

		[NativeName(NativeNameType.Func, "BeginShaderMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginShaderMode([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader)
		{
			BeginShaderModeNative(shader);
		}

		[NativeName(NativeNameType.Func, "EndShaderMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndShaderModeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[65])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[65])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EndShaderMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndShaderMode()
		{
			EndShaderModeNative();
		}

		[NativeName(NativeNameType.Func, "BeginBlendMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginBlendModeNative([NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "int")] int mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[66])(mode);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[66])(mode);
			#endif
		}

		[NativeName(NativeNameType.Func, "BeginBlendMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginBlendMode([NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "int")] int mode)
		{
			BeginBlendModeNative(mode);
		}

		[NativeName(NativeNameType.Func, "EndBlendMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndBlendModeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[67])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[67])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EndBlendMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndBlendMode()
		{
			EndBlendModeNative();
		}

		[NativeName(NativeNameType.Func, "BeginScissorMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginScissorModeNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[68])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[68])(x, y, width, height);
			#endif
		}

		[NativeName(NativeNameType.Func, "BeginScissorMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginScissorMode([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			BeginScissorModeNative(x, y, width, height);
		}

		[NativeName(NativeNameType.Func, "EndScissorMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndScissorModeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[69])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[69])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EndScissorMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndScissorMode()
		{
			EndScissorModeNative();
		}

		[NativeName(NativeNameType.Func, "BeginVrStereoMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginVrStereoModeNative([NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "VrStereoConfig")] VrStereoConfig config)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<VrStereoConfig, void>)funcTable[70])(config);
			#else
			((delegate* unmanaged[Cdecl]<VrStereoConfig, void>)funcTable[70])(config);
			#endif
		}

		[NativeName(NativeNameType.Func, "BeginVrStereoMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginVrStereoMode([NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "VrStereoConfig")] VrStereoConfig config)
		{
			BeginVrStereoModeNative(config);
		}

		[NativeName(NativeNameType.Func, "EndVrStereoMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndVrStereoModeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[71])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[71])();
			#endif
		}

		[NativeName(NativeNameType.Func, "EndVrStereoMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndVrStereoMode()
		{
			EndVrStereoModeNative();
		}

		/// <summary>
		/// VR stereo config functions for VR simulator<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadVrStereoConfig")]
		[return: NativeName(NativeNameType.Type, "VrStereoConfig")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static VrStereoConfig LoadVrStereoConfigNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VrDeviceInfo")] VrDeviceInfo device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<VrDeviceInfo, VrStereoConfig>)funcTable[72])(device);
			#else
			return (VrStereoConfig)((delegate* unmanaged[Cdecl]<VrDeviceInfo, VrStereoConfig>)funcTable[72])(device);
			#endif
		}

		/// <summary>
		/// VR stereo config functions for VR simulator<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadVrStereoConfig")]
		[return: NativeName(NativeNameType.Type, "VrStereoConfig")]
		public static VrStereoConfig LoadVrStereoConfig([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VrDeviceInfo")] VrDeviceInfo device)
		{
			VrStereoConfig ret = LoadVrStereoConfigNative(device);
			return ret;
		}

		[NativeName(NativeNameType.Func, "UnloadVrStereoConfig")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadVrStereoConfigNative([NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "VrStereoConfig")] VrStereoConfig config)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<VrStereoConfig, void>)funcTable[73])(config);
			#else
			((delegate* unmanaged[Cdecl]<VrStereoConfig, void>)funcTable[73])(config);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadVrStereoConfig")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadVrStereoConfig([NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "VrStereoConfig")] VrStereoConfig config)
		{
			UnloadVrStereoConfigNative(config);
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Shader LoadShaderNative([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fsFileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, Shader>)funcTable[74])(vsFileName, fsFileName);
			#else
			return (Shader)((delegate* unmanaged[Cdecl]<nint, nint, Shader>)funcTable[74])((nint)vsFileName, (nint)fsFileName);
			#endif
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fsFileName)
		{
			Shader ret = LoadShaderNative(vsFileName, fsFileName);
			return ret;
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fsFileName)
		{
			fixed (byte* pvsFileName = &vsFileName)
			{
				Shader ret = LoadShaderNative((byte*)pvsFileName, fsFileName);
				return ret;
			}
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fsFileName)
		{
			fixed (byte* pvsFileName = vsFileName)
			{
				Shader ret = LoadShaderNative((byte*)pvsFileName, fsFileName);
				return ret;
			}
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] string vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fsFileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (vsFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(vsFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(vsFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shader ret = LoadShaderNative(pStr0, fsFileName);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fsFileName)
		{
			fixed (byte* pfsFileName = &fsFileName)
			{
				Shader ret = LoadShaderNative(vsFileName, (byte*)pfsFileName);
				return ret;
			}
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fsFileName)
		{
			fixed (byte* pfsFileName = fsFileName)
			{
				Shader ret = LoadShaderNative(vsFileName, (byte*)pfsFileName);
				return ret;
			}
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] string fsFileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fsFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fsFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fsFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shader ret = LoadShaderNative(vsFileName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fsFileName)
		{
			fixed (byte* pvsFileName = &vsFileName)
			{
				fixed (byte* pfsFileName = &fsFileName)
				{
					Shader ret = LoadShaderNative((byte*)pvsFileName, (byte*)pfsFileName);
					return ret;
				}
			}
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fsFileName)
		{
			fixed (byte* pvsFileName = vsFileName)
			{
				fixed (byte* pfsFileName = fsFileName)
				{
					Shader ret = LoadShaderNative((byte*)pvsFileName, (byte*)pfsFileName);
					return ret;
				}
			}
		}

		/// <summary>
		/// Shader management functions<br/>
		/// NOTE: Shader functionality is not available on OpenGL 1.1<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadShader")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShader([NativeName(NativeNameType.Param, "vsFileName")] [NativeName(NativeNameType.Type, "char const *")] string vsFileName, [NativeName(NativeNameType.Param, "fsFileName")] [NativeName(NativeNameType.Type, "char const *")] string fsFileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (vsFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(vsFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(vsFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fsFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fsFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fsFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shader ret = LoadShaderNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Shader LoadShaderFromMemoryNative([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* fsCode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, Shader>)funcTable[75])(vsCode, fsCode);
			#else
			return (Shader)((delegate* unmanaged[Cdecl]<nint, nint, Shader>)funcTable[75])((nint)vsCode, (nint)fsCode);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* fsCode)
		{
			Shader ret = LoadShaderFromMemoryNative(vsCode, fsCode);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] ref byte vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* fsCode)
		{
			fixed (byte* pvsCode = &vsCode)
			{
				Shader ret = LoadShaderFromMemoryNative((byte*)pvsCode, fsCode);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* fsCode)
		{
			fixed (byte* pvsCode = vsCode)
			{
				Shader ret = LoadShaderFromMemoryNative((byte*)pvsCode, fsCode);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] string vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* fsCode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (vsCode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(vsCode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(vsCode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shader ret = LoadShaderFromMemoryNative(pStr0, fsCode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fsCode)
		{
			fixed (byte* pfsCode = &fsCode)
			{
				Shader ret = LoadShaderFromMemoryNative(vsCode, (byte*)pfsCode);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fsCode)
		{
			fixed (byte* pfsCode = fsCode)
			{
				Shader ret = LoadShaderFromMemoryNative(vsCode, (byte*)pfsCode);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] byte* vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] string fsCode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fsCode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fsCode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fsCode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shader ret = LoadShaderFromMemoryNative(vsCode, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] ref byte vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fsCode)
		{
			fixed (byte* pvsCode = &vsCode)
			{
				fixed (byte* pfsCode = &fsCode)
				{
					Shader ret = LoadShaderFromMemoryNative((byte*)pvsCode, (byte*)pfsCode);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fsCode)
		{
			fixed (byte* pvsCode = vsCode)
			{
				fixed (byte* pfsCode = fsCode)
				{
					Shader ret = LoadShaderFromMemoryNative((byte*)pvsCode, (byte*)pfsCode);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "LoadShaderFromMemory")]
		[return: NativeName(NativeNameType.Type, "Shader")]
		public static Shader LoadShaderFromMemory([NativeName(NativeNameType.Param, "vsCode")] [NativeName(NativeNameType.Type, "char const *")] string vsCode, [NativeName(NativeNameType.Param, "fsCode")] [NativeName(NativeNameType.Type, "char const *")] string fsCode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (vsCode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(vsCode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(vsCode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fsCode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fsCode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fsCode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shader ret = LoadShaderFromMemoryNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "IsShaderValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsShaderValidNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Shader, byte>)funcTable[76])(shader);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Shader, byte>)funcTable[76])(shader);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsShaderValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsShaderValid([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader)
		{
			byte ret = IsShaderValidNative(shader);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "GetShaderLocation")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetShaderLocationNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "uniformName")] [NativeName(NativeNameType.Type, "char const *")] byte* uniformName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Shader, byte*, int>)funcTable[77])(shader, uniformName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<Shader, nint, int>)funcTable[77])(shader, (nint)uniformName);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetShaderLocation")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetShaderLocation([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "uniformName")] [NativeName(NativeNameType.Type, "char const *")] byte* uniformName)
		{
			int ret = GetShaderLocationNative(shader, uniformName);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetShaderLocation")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetShaderLocation([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "uniformName")] [NativeName(NativeNameType.Type, "char const *")] ref byte uniformName)
		{
			fixed (byte* puniformName = &uniformName)
			{
				int ret = GetShaderLocationNative(shader, (byte*)puniformName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetShaderLocation")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetShaderLocation([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "uniformName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> uniformName)
		{
			fixed (byte* puniformName = uniformName)
			{
				int ret = GetShaderLocationNative(shader, (byte*)puniformName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetShaderLocation")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetShaderLocation([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "uniformName")] [NativeName(NativeNameType.Type, "char const *")] string uniformName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetShaderLocationNative(shader, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetShaderLocationAttrib")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetShaderLocationAttribNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "attribName")] [NativeName(NativeNameType.Type, "char const *")] byte* attribName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Shader, byte*, int>)funcTable[78])(shader, attribName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<Shader, nint, int>)funcTable[78])(shader, (nint)attribName);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetShaderLocationAttrib")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetShaderLocationAttrib([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "attribName")] [NativeName(NativeNameType.Type, "char const *")] byte* attribName)
		{
			int ret = GetShaderLocationAttribNative(shader, attribName);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetShaderLocationAttrib")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetShaderLocationAttrib([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "attribName")] [NativeName(NativeNameType.Type, "char const *")] ref byte attribName)
		{
			fixed (byte* pattribName = &attribName)
			{
				int ret = GetShaderLocationAttribNative(shader, (byte*)pattribName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetShaderLocationAttrib")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetShaderLocationAttrib([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "attribName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> attribName)
		{
			fixed (byte* pattribName = attribName)
			{
				int ret = GetShaderLocationAttribNative(shader, (byte*)pattribName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetShaderLocationAttrib")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetShaderLocationAttrib([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "attribName")] [NativeName(NativeNameType.Type, "char const *")] string attribName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (attribName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(attribName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(attribName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetShaderLocationAttribNative(shader, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SetShaderValue")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetShaderValueNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "locIndex")] [NativeName(NativeNameType.Type, "int")] int locIndex, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "uniformType")] [NativeName(NativeNameType.Type, "int")] int uniformType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Shader, int, void*, int, void>)funcTable[79])(shader, locIndex, value, uniformType);
			#else
			((delegate* unmanaged[Cdecl]<Shader, int, nint, int, void>)funcTable[79])(shader, locIndex, (nint)value, uniformType);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetShaderValue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetShaderValue([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "locIndex")] [NativeName(NativeNameType.Type, "int")] int locIndex, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "uniformType")] [NativeName(NativeNameType.Type, "int")] int uniformType)
		{
			SetShaderValueNative(shader, locIndex, value, uniformType);
		}

		[NativeName(NativeNameType.Func, "SetShaderValueV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetShaderValueVNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "locIndex")] [NativeName(NativeNameType.Type, "int")] int locIndex, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "uniformType")] [NativeName(NativeNameType.Type, "int")] int uniformType, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Shader, int, void*, int, int, void>)funcTable[80])(shader, locIndex, value, uniformType, count);
			#else
			((delegate* unmanaged[Cdecl]<Shader, int, nint, int, int, void>)funcTable[80])(shader, locIndex, (nint)value, uniformType, count);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetShaderValueV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetShaderValueV([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "locIndex")] [NativeName(NativeNameType.Type, "int")] int locIndex, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "uniformType")] [NativeName(NativeNameType.Type, "int")] int uniformType, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			SetShaderValueVNative(shader, locIndex, value, uniformType, count);
		}

		[NativeName(NativeNameType.Func, "SetShaderValueMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetShaderValueMatrixNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "locIndex")] [NativeName(NativeNameType.Type, "int")] int locIndex, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "Matrix")] Matrix4x4 mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Shader, int, Matrix4x4, void>)funcTable[81])(shader, locIndex, mat);
			#else
			((delegate* unmanaged[Cdecl]<Shader, int, Matrix4x4, void>)funcTable[81])(shader, locIndex, mat);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetShaderValueMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetShaderValueMatrix([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "locIndex")] [NativeName(NativeNameType.Type, "int")] int locIndex, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "Matrix")] Matrix4x4 mat)
		{
			SetShaderValueMatrixNative(shader, locIndex, mat);
		}

		[NativeName(NativeNameType.Func, "SetShaderValueTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetShaderValueTextureNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "locIndex")] [NativeName(NativeNameType.Type, "int")] int locIndex, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Shader, int, Texture, void>)funcTable[82])(shader, locIndex, texture);
			#else
			((delegate* unmanaged[Cdecl]<Shader, int, Texture, void>)funcTable[82])(shader, locIndex, texture);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetShaderValueTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetShaderValueTexture([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader, [NativeName(NativeNameType.Param, "locIndex")] [NativeName(NativeNameType.Type, "int")] int locIndex, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "Texture2D")] Texture texture)
		{
			SetShaderValueTextureNative(shader, locIndex, texture);
		}

		[NativeName(NativeNameType.Func, "UnloadShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadShaderNative([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Shader, void>)funcTable[83])(shader);
			#else
			((delegate* unmanaged[Cdecl]<Shader, void>)funcTable[83])(shader);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadShader([NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "Shader")] Shader shader)
		{
			UnloadShaderNative(shader);
		}

		[NativeName(NativeNameType.Func, "GetScreenToWorldRay")]
		[return: NativeName(NativeNameType.Type, "Ray")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Ray GetScreenToWorldRayNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Camera3D, Ray>)funcTable[84])(position, camera);
			#else
			return (Ray)((delegate* unmanaged[Cdecl]<Vector2, Camera3D, Ray>)funcTable[84])(position, camera);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetScreenToWorldRay")]
		[return: NativeName(NativeNameType.Type, "Ray")]
		public static Ray GetScreenToWorldRay([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera)
		{
			Ray ret = GetScreenToWorldRayNative(position, camera);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetScreenToWorldRayEx")]
		[return: NativeName(NativeNameType.Type, "Ray")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Ray GetScreenToWorldRayExNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Camera3D, int, int, Ray>)funcTable[85])(position, camera, width, height);
			#else
			return (Ray)((delegate* unmanaged[Cdecl]<Vector2, Camera3D, int, int, Ray>)funcTable[85])(position, camera, width, height);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetScreenToWorldRayEx")]
		[return: NativeName(NativeNameType.Type, "Ray")]
		public static Ray GetScreenToWorldRayEx([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			Ray ret = GetScreenToWorldRayExNative(position, camera, width, height);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetWorldToScreen")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetWorldToScreenNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector3, Camera3D, Vector2>)funcTable[86])(position, camera);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector3, Camera3D, Vector2>)funcTable[86])(position, camera);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetWorldToScreen")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetWorldToScreen([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera)
		{
			Vector2 ret = GetWorldToScreenNative(position, camera);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetWorldToScreenEx")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetWorldToScreenExNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector3, Camera3D, int, int, Vector2>)funcTable[87])(position, camera, width, height);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector3, Camera3D, int, int, Vector2>)funcTable[87])(position, camera, width, height);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetWorldToScreenEx")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetWorldToScreenEx([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector3")] Vector3 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			Vector2 ret = GetWorldToScreenExNative(position, camera, width, height);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetWorldToScreen2D")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetWorldToScreen2DNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera2D")] Camera2D camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Camera2D, Vector2>)funcTable[88])(position, camera);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Camera2D, Vector2>)funcTable[88])(position, camera);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetWorldToScreen2D")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetWorldToScreen2D([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera2D")] Camera2D camera)
		{
			Vector2 ret = GetWorldToScreen2DNative(position, camera);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetScreenToWorld2D")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 GetScreenToWorld2DNative([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera2D")] Camera2D camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Camera2D, Vector2>)funcTable[89])(position, camera);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Camera2D, Vector2>)funcTable[89])(position, camera);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetScreenToWorld2D")]
		[return: NativeName(NativeNameType.Type, "Vector2")]
		public static Vector2 GetScreenToWorld2D([NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "Vector2")] Vector2 position, [NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera2D")] Camera2D camera)
		{
			Vector2 ret = GetScreenToWorld2DNative(position, camera);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCameraMatrix")]
		[return: NativeName(NativeNameType.Type, "Matrix")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Matrix4x4 GetCameraMatrixNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Camera3D, Matrix4x4>)funcTable[90])(camera);
			#else
			return (Matrix4x4)((delegate* unmanaged[Cdecl]<Camera3D, Matrix4x4>)funcTable[90])(camera);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCameraMatrix")]
		[return: NativeName(NativeNameType.Type, "Matrix")]
		public static Matrix4x4 GetCameraMatrix([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera")] Camera3D camera)
		{
			Matrix4x4 ret = GetCameraMatrixNative(camera);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetCameraMatrix2D")]
		[return: NativeName(NativeNameType.Type, "Matrix")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Matrix4x4 GetCameraMatrix2DNative([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera2D")] Camera2D camera)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Camera2D, Matrix4x4>)funcTable[91])(camera);
			#else
			return (Matrix4x4)((delegate* unmanaged[Cdecl]<Camera2D, Matrix4x4>)funcTable[91])(camera);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetCameraMatrix2D")]
		[return: NativeName(NativeNameType.Type, "Matrix")]
		public static Matrix4x4 GetCameraMatrix2D([NativeName(NativeNameType.Param, "camera")] [NativeName(NativeNameType.Type, "Camera2D")] Camera2D camera)
		{
			Matrix4x4 ret = GetCameraMatrix2DNative(camera);
			return ret;
		}

		/// <summary>
		/// Timing-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetTargetFPS")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTargetFPSNative([NativeName(NativeNameType.Param, "fps")] [NativeName(NativeNameType.Type, "int")] int fps)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[92])(fps);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[92])(fps);
			#endif
		}

		/// <summary>
		/// Timing-related functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetTargetFPS")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTargetFPS([NativeName(NativeNameType.Param, "fps")] [NativeName(NativeNameType.Type, "int")] int fps)
		{
			SetTargetFPSNative(fps);
		}

		[NativeName(NativeNameType.Func, "GetFrameTime")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFrameTimeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[93])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[93])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetFrameTime")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFrameTime()
		{
			float ret = GetFrameTimeNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetTime")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double GetTimeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)funcTable[94])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)funcTable[94])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetTime")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double GetTime()
		{
			double ret = GetTimeNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFPS")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFPSNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[95])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[95])();
			#endif
		}

		[NativeName(NativeNameType.Func, "GetFPS")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetFPS()
		{
			int ret = GetFPSNative();
			return ret;
		}

		/// <summary>
		/// Custom frame control functions<br/>
		/// NOTE: Those functions are intended for advanced users that want full control over the frame processing<br/>
		/// By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timing + PollInputEvents()<br/>
		/// To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SwapScreenBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SwapScreenBufferNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[96])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[96])();
			#endif
		}

		/// <summary>
		/// Custom frame control functions<br/>
		/// NOTE: Those functions are intended for advanced users that want full control over the frame processing<br/>
		/// By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timing + PollInputEvents()<br/>
		/// To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SwapScreenBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SwapScreenBuffer()
		{
			SwapScreenBufferNative();
		}

		[NativeName(NativeNameType.Func, "PollInputEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PollInputEventsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[97])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[97])();
			#endif
		}

		[NativeName(NativeNameType.Func, "PollInputEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PollInputEvents()
		{
			PollInputEventsNative();
		}

		[NativeName(NativeNameType.Func, "WaitTime")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitTimeNative([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "double")] double seconds)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[98])(seconds);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[98])(seconds);
			#endif
		}

		[NativeName(NativeNameType.Func, "WaitTime")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitTime([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "double")] double seconds)
		{
			WaitTimeNative(seconds);
		}

		/// <summary>
		/// Random values generation functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetRandomSeed")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetRandomSeedNative([NativeName(NativeNameType.Param, "seed")] [NativeName(NativeNameType.Type, "unsigned int")] uint seed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[99])(seed);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[99])(seed);
			#endif
		}

		/// <summary>
		/// Random values generation functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetRandomSeed")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetRandomSeed([NativeName(NativeNameType.Param, "seed")] [NativeName(NativeNameType.Type, "unsigned int")] uint seed)
		{
			SetRandomSeedNative(seed);
		}

		[NativeName(NativeNameType.Func, "GetRandomValue")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRandomValueNative([NativeName(NativeNameType.Param, "min")] [NativeName(NativeNameType.Type, "int")] int min, [NativeName(NativeNameType.Param, "max")] [NativeName(NativeNameType.Type, "int")] int max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[100])(min, max);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[100])(min, max);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetRandomValue")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRandomValue([NativeName(NativeNameType.Param, "min")] [NativeName(NativeNameType.Type, "int")] int min, [NativeName(NativeNameType.Param, "max")] [NativeName(NativeNameType.Type, "int")] int max)
		{
			int ret = GetRandomValueNative(min, max);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadRandomSequence")]
		[return: NativeName(NativeNameType.Type, "int *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* LoadRandomSequenceNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "unsigned int")] uint count, [NativeName(NativeNameType.Param, "min")] [NativeName(NativeNameType.Type, "int")] int min, [NativeName(NativeNameType.Param, "max")] [NativeName(NativeNameType.Type, "int")] int max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, int*>)funcTable[101])(count, min, max);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<uint, int, int, nint>)funcTable[101])(count, min, max);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadRandomSequence")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* LoadRandomSequence([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "unsigned int")] uint count, [NativeName(NativeNameType.Param, "min")] [NativeName(NativeNameType.Type, "int")] int min, [NativeName(NativeNameType.Param, "max")] [NativeName(NativeNameType.Type, "int")] int max)
		{
			int* ret = LoadRandomSequenceNative(count, min, max);
			return ret;
		}

		[NativeName(NativeNameType.Func, "UnloadRandomSequence")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadRandomSequenceNative([NativeName(NativeNameType.Param, "sequence")] [NativeName(NativeNameType.Type, "int *")] int* sequence)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[102])(sequence);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[102])((nint)sequence);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadRandomSequence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadRandomSequence([NativeName(NativeNameType.Param, "sequence")] [NativeName(NativeNameType.Type, "int *")] int* sequence)
		{
			UnloadRandomSequenceNative(sequence);
		}

		[NativeName(NativeNameType.Func, "UnloadRandomSequence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadRandomSequence([NativeName(NativeNameType.Param, "sequence")] [NativeName(NativeNameType.Type, "int *")] ref int sequence)
		{
			fixed (int* psequence = &sequence)
			{
				UnloadRandomSequenceNative((int*)psequence);
			}
		}

		/// <summary>
		/// Misc. functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TakeScreenshot")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TakeScreenshotNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[103])(fileName);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[103])((nint)fileName);
			#endif
		}

		/// <summary>
		/// Misc. functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TakeScreenshot")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TakeScreenshot([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			TakeScreenshotNative(fileName);
		}

		/// <summary>
		/// Misc. functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TakeScreenshot")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TakeScreenshot([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				TakeScreenshotNative((byte*)pfileName);
			}
		}

		/// <summary>
		/// Misc. functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TakeScreenshot")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TakeScreenshot([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				TakeScreenshotNative((byte*)pfileName);
			}
		}

		/// <summary>
		/// Misc. functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TakeScreenshot")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TakeScreenshot([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TakeScreenshotNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "SetConfigFlags")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetConfigFlagsNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "unsigned int")] uint flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[104])(flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[104])(flags);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetConfigFlags")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetConfigFlags([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "unsigned int")] uint flags)
		{
			SetConfigFlagsNative(flags);
		}

		[NativeName(NativeNameType.Func, "OpenURL")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OpenURLNative([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "char const *")] byte* url)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[105])(url);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[105])((nint)url);
			#endif
		}

		[NativeName(NativeNameType.Func, "OpenURL")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OpenURL([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "char const *")] byte* url)
		{
			OpenURLNative(url);
		}

		[NativeName(NativeNameType.Func, "OpenURL")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OpenURL([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "char const *")] ref byte url)
		{
			fixed (byte* purl = &url)
			{
				OpenURLNative((byte*)purl);
			}
		}

		[NativeName(NativeNameType.Func, "OpenURL")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OpenURL([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> url)
		{
			fixed (byte* purl = url)
			{
				OpenURLNative((byte*)purl);
			}
		}

		[NativeName(NativeNameType.Func, "OpenURL")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OpenURL([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "char const *")] string url)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (url != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(url);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(url, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			OpenURLNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// NOTE: Following functions implemented in module [utils]<br/>
		/// ------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TraceLog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TraceLogNative([NativeName(NativeNameType.Param, "logLevel")] [NativeName(NativeNameType.Type, "int")] int logLevel, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[106])(logLevel, text);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[106])(logLevel, (nint)text);
			#endif
		}

		/// <summary>
		/// NOTE: Following functions implemented in module [utils]<br/>
		/// ------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TraceLog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TraceLog([NativeName(NativeNameType.Param, "logLevel")] [NativeName(NativeNameType.Type, "int")] int logLevel, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			TraceLogNative(logLevel, text);
		}

		/// <summary>
		/// NOTE: Following functions implemented in module [utils]<br/>
		/// ------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TraceLog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TraceLog([NativeName(NativeNameType.Param, "logLevel")] [NativeName(NativeNameType.Type, "int")] int logLevel, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				TraceLogNative(logLevel, (byte*)ptext);
			}
		}

		/// <summary>
		/// NOTE: Following functions implemented in module [utils]<br/>
		/// ------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TraceLog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TraceLog([NativeName(NativeNameType.Param, "logLevel")] [NativeName(NativeNameType.Type, "int")] int logLevel, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				TraceLogNative(logLevel, (byte*)ptext);
			}
		}

		/// <summary>
		/// NOTE: Following functions implemented in module [utils]<br/>
		/// ------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "TraceLog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TraceLog([NativeName(NativeNameType.Param, "logLevel")] [NativeName(NativeNameType.Type, "int")] int logLevel, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TraceLogNative(logLevel, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "SetTraceLogLevel")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTraceLogLevelNative([NativeName(NativeNameType.Param, "logLevel")] [NativeName(NativeNameType.Type, "int")] int logLevel)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[107])(logLevel);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[107])(logLevel);
			#endif
		}

		[NativeName(NativeNameType.Func, "SetTraceLogLevel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTraceLogLevel([NativeName(NativeNameType.Param, "logLevel")] [NativeName(NativeNameType.Type, "int")] int logLevel)
		{
			SetTraceLogLevelNative(logLevel);
		}

		[NativeName(NativeNameType.Func, "MemAlloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemAllocNative([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "unsigned int")] uint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*>)funcTable[108])(size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[108])(size);
			#endif
		}

		[NativeName(NativeNameType.Func, "MemAlloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MemAlloc([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "unsigned int")] uint size)
		{
			void* ret = MemAllocNative(size);
			return ret;
		}

		[NativeName(NativeNameType.Func, "MemRealloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemReallocNative([NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "unsigned int")] uint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, uint, void*>)funcTable[109])(ptr, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[109])((nint)ptr, size);
			#endif
		}

		[NativeName(NativeNameType.Func, "MemRealloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MemRealloc([NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "unsigned int")] uint size)
		{
			void* ret = MemReallocNative(ptr, size);
			return ret;
		}

		[NativeName(NativeNameType.Func, "MemFree")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemFreeNative([NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[110])(ptr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[110])((nint)ptr);
			#endif
		}

		[NativeName(NativeNameType.Func, "MemFree")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MemFree([NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr)
		{
			MemFreeNative(ptr);
		}

		/// <summary>
		/// Set custom callbacks<br/>
		/// WARNING: Callbacks setup is intended for advanced users<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetTraceLogCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTraceLogCallbackNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "TraceLogCallback")] TraceLogCallback callback)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<int, byte*, nint, void>, void>)funcTable[111])((delegate*<int, byte*, nint, void>)Utils.GetFunctionPointerForDelegate(callback));
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[111])((nint)Utils.GetFunctionPointerForDelegate(callback));
			#endif
		}

		/// <summary>
		/// Set custom callbacks<br/>
		/// WARNING: Callbacks setup is intended for advanced users<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SetTraceLogCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTraceLogCallback([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "TraceLogCallback")] TraceLogCallback callback)
		{
			SetTraceLogCallbackNative(callback);
		}

		[NativeName(NativeNameType.Func, "SetLoadFileDataCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetLoadFileDataCallbackNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "LoadFileDataCallback")] LoadFileDataCallback callback)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<byte*, int*, byte*>, void>)funcTable[112])((delegate*<byte*, int*, byte*>)Utils.GetFunctionPointerForDelegate(callback));
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[112])((nint)Utils.GetFunctionPointerForDelegate(callback));
			#endif
		}

		[NativeName(NativeNameType.Func, "SetLoadFileDataCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetLoadFileDataCallback([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "LoadFileDataCallback")] LoadFileDataCallback callback)
		{
			SetLoadFileDataCallbackNative(callback);
		}

		[NativeName(NativeNameType.Func, "SetSaveFileDataCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSaveFileDataCallbackNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SaveFileDataCallback")] SaveFileDataCallback callback)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<byte*, void*, int, bool>, void>)funcTable[113])((delegate*<byte*, void*, int, bool>)Utils.GetFunctionPointerForDelegate(callback));
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[113])((nint)Utils.GetFunctionPointerForDelegate(callback));
			#endif
		}

		[NativeName(NativeNameType.Func, "SetSaveFileDataCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetSaveFileDataCallback([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SaveFileDataCallback")] SaveFileDataCallback callback)
		{
			SetSaveFileDataCallbackNative(callback);
		}

		[NativeName(NativeNameType.Func, "SetLoadFileTextCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetLoadFileTextCallbackNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "LoadFileTextCallback")] LoadFileTextCallback callback)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<byte*, byte*>, void>)funcTable[114])((delegate*<byte*, byte*>)Utils.GetFunctionPointerForDelegate(callback));
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[114])((nint)Utils.GetFunctionPointerForDelegate(callback));
			#endif
		}

		[NativeName(NativeNameType.Func, "SetLoadFileTextCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetLoadFileTextCallback([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "LoadFileTextCallback")] LoadFileTextCallback callback)
		{
			SetLoadFileTextCallbackNative(callback);
		}

		[NativeName(NativeNameType.Func, "SetSaveFileTextCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSaveFileTextCallbackNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SaveFileTextCallback")] SaveFileTextCallback callback)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<byte*, byte*, bool>, void>)funcTable[115])((delegate*<byte*, byte*, bool>)Utils.GetFunctionPointerForDelegate(callback));
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[115])((nint)Utils.GetFunctionPointerForDelegate(callback));
			#endif
		}

		[NativeName(NativeNameType.Func, "SetSaveFileTextCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetSaveFileTextCallback([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SaveFileTextCallback")] SaveFileTextCallback callback)
		{
			SetSaveFileTextCallbackNative(callback);
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* LoadFileDataNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, byte*>)funcTable[116])(fileName, dataSize);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[116])((nint)fileName, (nint)dataSize);
			#endif
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* LoadFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			byte* ret = LoadFileDataNative(fileName, dataSize);
			return ret;
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string LoadFileDataS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			string ret = Utils.DecodeStringUTF8(LoadFileDataNative(fileName, dataSize));
			return ret;
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* LoadFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte* ret = LoadFileDataNative((byte*)pfileName, dataSize);
				return ret;
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string LoadFileDataS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			fixed (byte* pfileName = &fileName)
			{
				string ret = Utils.DecodeStringUTF8(LoadFileDataNative((byte*)pfileName, dataSize));
				return ret;
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* LoadFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			fixed (byte* pfileName = fileName)
			{
				byte* ret = LoadFileDataNative((byte*)pfileName, dataSize);
				return ret;
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string LoadFileDataS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			fixed (byte* pfileName = fileName)
			{
				string ret = Utils.DecodeStringUTF8(LoadFileDataNative((byte*)pfileName, dataSize));
				return ret;
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* LoadFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = LoadFileDataNative(pStr0, dataSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string LoadFileDataS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] int* dataSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(LoadFileDataNative(pStr0, dataSize));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* LoadFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (int* pdataSize = &dataSize)
			{
				byte* ret = LoadFileDataNative(fileName, (int*)pdataSize);
				return ret;
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string LoadFileDataS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (int* pdataSize = &dataSize)
			{
				string ret = Utils.DecodeStringUTF8(LoadFileDataNative(fileName, (int*)pdataSize));
				return ret;
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* LoadFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (byte* pfileName = &fileName)
			{
				fixed (int* pdataSize = &dataSize)
				{
					byte* ret = LoadFileDataNative((byte*)pfileName, (int*)pdataSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string LoadFileDataS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (byte* pfileName = &fileName)
			{
				fixed (int* pdataSize = &dataSize)
				{
					string ret = Utils.DecodeStringUTF8(LoadFileDataNative((byte*)pfileName, (int*)pdataSize));
					return ret;
				}
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* LoadFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (byte* pfileName = fileName)
			{
				fixed (int* pdataSize = &dataSize)
				{
					byte* ret = LoadFileDataNative((byte*)pfileName, (int*)pdataSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string LoadFileDataS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			fixed (byte* pfileName = fileName)
			{
				fixed (int* pdataSize = &dataSize)
				{
					string ret = Utils.DecodeStringUTF8(LoadFileDataNative((byte*)pfileName, (int*)pdataSize));
					return ret;
				}
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static byte* LoadFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pdataSize = &dataSize)
			{
				byte* ret = LoadFileDataNative(pStr0, (int*)pdataSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Files management functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "LoadFileData")]
		[return: NativeName(NativeNameType.Type, "unsigned char *")]
		public static string LoadFileDataS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int *")] ref int dataSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pdataSize = &dataSize)
			{
				string ret = Utils.DecodeStringUTF8(LoadFileDataNative(pStr0, (int*)pdataSize));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "UnloadFileData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadFileDataNative([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[117])(data);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[117])((nint)data);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadFileData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadFileData([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data)
		{
			UnloadFileDataNative(data);
		}

		[NativeName(NativeNameType.Func, "UnloadFileData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadFileData([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data)
		{
			fixed (byte* pdata = &data)
			{
				UnloadFileDataNative((byte*)pdata);
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveFileDataNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*, int, byte>)funcTable[118])(fileName, data, dataSize);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[118])((nint)fileName, (nint)data, dataSize);
			#endif
		}

		[NativeName(NativeNameType.Func, "SaveFileData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			byte ret = SaveFileDataNative(fileName, data, dataSize);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SaveFileData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = SaveFileDataNative((byte*)pfileName, data, dataSize);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = SaveFileDataNative((byte*)pfileName, data, dataSize);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileData([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveFileDataNative(pStr0, data, dataSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ExportDataAsCodeNative([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*, byte>)funcTable[119])(data, dataSize, fileName);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, byte>)funcTable[119])((nint)data, dataSize, (nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportDataAsCode([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			byte ret = ExportDataAsCodeNative(data, dataSize, fileName);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportDataAsCode([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			fixed (byte* pdata = &data)
			{
				byte ret = ExportDataAsCodeNative((byte*)pdata, dataSize, fileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportDataAsCode([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = ExportDataAsCodeNative(data, dataSize, (byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportDataAsCode([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = ExportDataAsCodeNative(data, dataSize, (byte*)pfileName);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportDataAsCode([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ExportDataAsCodeNative(data, dataSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportDataAsCode([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pdata = &data)
			{
				fixed (byte* pfileName = &fileName)
				{
					byte ret = ExportDataAsCodeNative((byte*)pdata, dataSize, (byte*)pfileName);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportDataAsCode([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pdata = &data)
			{
				fixed (byte* pfileName = fileName)
				{
					byte ret = ExportDataAsCodeNative((byte*)pdata, dataSize, (byte*)pfileName);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "ExportDataAsCode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ExportDataAsCode([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] ref byte data, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "int")] int dataSize, [NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			fixed (byte* pdata = &data)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fileName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fileName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ExportDataAsCodeNative((byte*)pdata, dataSize, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* LoadFileTextNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[120])(fileName);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[120])((nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* LoadFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			byte* ret = LoadFileTextNative(fileName);
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LoadFileTextS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			string ret = Utils.DecodeStringUTF8(LoadFileTextNative(fileName));
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* LoadFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte* ret = LoadFileTextNative((byte*)pfileName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LoadFileTextS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				string ret = Utils.DecodeStringUTF8(LoadFileTextNative((byte*)pfileName));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* LoadFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				byte* ret = LoadFileTextNative((byte*)pfileName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LoadFileTextS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				string ret = Utils.DecodeStringUTF8(LoadFileTextNative((byte*)pfileName));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* LoadFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = LoadFileTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "LoadFileText")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string LoadFileTextS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(LoadFileTextNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "UnloadFileText")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnloadFileTextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[121])(text);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[121])((nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "UnloadFileText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadFileText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			UnloadFileTextNative(text);
		}

		[NativeName(NativeNameType.Func, "UnloadFileText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadFileText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				UnloadFileTextNative((byte*)ptext);
			}
		}

		[NativeName(NativeNameType.Func, "UnloadFileText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnloadFileText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			UnloadFileTextNative(pStr0);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveFileTextNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)funcTable[122])(fileName, text);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[122])((nint)fileName, (nint)text);
			#endif
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			byte ret = SaveFileTextNative(fileName, text);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = SaveFileTextNative((byte*)pfileName, text);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = SaveFileTextNative((byte*)pfileName, text);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] byte* text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveFileTextNative(pStr0, text);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = SaveFileTextNative(fileName, (byte*)ptext);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveFileTextNative(fileName, pStr0);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text)
		{
			fixed (byte* pfileName = &fileName)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = SaveFileTextNative((byte*)pfileName, (byte*)ptext);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref byte text)
		{
			fixed (byte* pfileName = fileName)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = SaveFileTextNative((byte*)pfileName, (byte*)ptext);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SaveFileText")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileText([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char *")] ref string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (text != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(text);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(text, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SaveFileTextNative(pStr0, pStr1);
			text = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// File system functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FileExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FileExistsNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[123])(fileName);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[123])((nint)fileName);
			#endif
		}

		/// <summary>
		/// File system functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FileExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FileExists([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			byte ret = FileExistsNative(fileName);
			return ret != 0;
		}

		/// <summary>
		/// File system functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FileExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FileExists([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = FileExistsNative((byte*)pfileName);
				return ret != 0;
			}
		}

		/// <summary>
		/// File system functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FileExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FileExists([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = FileExistsNative((byte*)pfileName);
				return ret != 0;
			}
		}

		/// <summary>
		/// File system functions<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FileExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FileExists([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = FileExistsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "DirectoryExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DirectoryExistsNative([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[124])(dirPath);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[124])((nint)dirPath);
			#endif
		}

		[NativeName(NativeNameType.Func, "DirectoryExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DirectoryExists([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] byte* dirPath)
		{
			byte ret = DirectoryExistsNative(dirPath);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "DirectoryExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DirectoryExists([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ref byte dirPath)
		{
			fixed (byte* pdirPath = &dirPath)
			{
				byte ret = DirectoryExistsNative((byte*)pdirPath);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "DirectoryExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DirectoryExists([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> dirPath)
		{
			fixed (byte* pdirPath = dirPath)
			{
				byte ret = DirectoryExistsNative((byte*)pdirPath);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "DirectoryExists")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DirectoryExists([NativeName(NativeNameType.Param, "dirPath")] [NativeName(NativeNameType.Type, "char const *")] string dirPath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dirPath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dirPath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dirPath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DirectoryExistsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFileExtensionNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] byte* ext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)funcTable[125])(fileName, ext);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[125])((nint)fileName, (nint)ext);
			#endif
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] byte* ext)
		{
			byte ret = IsFileExtensionNative(fileName, ext);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] byte* ext)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte ret = IsFileExtensionNative((byte*)pfileName, ext);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] byte* ext)
		{
			fixed (byte* pfileName = fileName)
			{
				byte ret = IsFileExtensionNative((byte*)pfileName, ext);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] byte* ext)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsFileExtensionNative(pStr0, ext);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] ref byte ext)
		{
			fixed (byte* pext = &ext)
			{
				byte ret = IsFileExtensionNative(fileName, (byte*)pext);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> ext)
		{
			fixed (byte* pext = ext)
			{
				byte ret = IsFileExtensionNative(fileName, (byte*)pext);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] string ext)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (ext != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(ext);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(ext, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsFileExtensionNative(fileName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] ref byte ext)
		{
			fixed (byte* pfileName = &fileName)
			{
				fixed (byte* pext = &ext)
				{
					byte ret = IsFileExtensionNative((byte*)pfileName, (byte*)pext);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> ext)
		{
			fixed (byte* pfileName = fileName)
			{
				fixed (byte* pext = ext)
				{
					byte ret = IsFileExtensionNative((byte*)pfileName, (byte*)pext);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "IsFileExtension")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName, [NativeName(NativeNameType.Param, "ext")] [NativeName(NativeNameType.Type, "char const *")] string ext)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (ext != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(ext);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(ext, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = IsFileExtensionNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "GetFileLength")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFileLengthNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[126])(fileName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[126])((nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetFileLength")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetFileLength([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			int ret = GetFileLengthNative(fileName);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileLength")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetFileLength([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				int ret = GetFileLengthNative((byte*)pfileName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileLength")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetFileLength([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				int ret = GetFileLengthNative((byte*)pfileName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileLength")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetFileLength([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFileLengthNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetFileExtensionNative([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[127])(fileName);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[127])((nint)fileName);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			byte* ret = GetFileExtensionNative(fileName);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileExtensionS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] byte* fileName)
		{
			string ret = Utils.DecodeStringUTF8(GetFileExtensionNative(fileName));
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				byte* ret = GetFileExtensionNative((byte*)pfileName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileExtensionS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				string ret = Utils.DecodeStringUTF8(GetFileExtensionNative((byte*)pfileName));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				byte* ret = GetFileExtensionNative((byte*)pfileName);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileExtensionS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				string ret = Utils.DecodeStringUTF8(GetFileExtensionNative((byte*)pfileName));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileExtension([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetFileExtensionNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileExtension")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileExtensionS([NativeName(NativeNameType.Param, "fileName")] [NativeName(NativeNameType.Type, "char const *")] string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetFileExtensionNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetFileNameNative([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[128])(filePath);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[128])((nint)filePath);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileName([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			byte* ret = GetFileNameNative(filePath);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileNameS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			string ret = Utils.DecodeStringUTF8(GetFileNameNative(filePath));
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileName([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ref byte filePath)
		{
			fixed (byte* pfilePath = &filePath)
			{
				byte* ret = GetFileNameNative((byte*)pfilePath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileNameS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ref byte filePath)
		{
			fixed (byte* pfilePath = &filePath)
			{
				string ret = Utils.DecodeStringUTF8(GetFileNameNative((byte*)pfilePath));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileName([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filePath)
		{
			fixed (byte* pfilePath = filePath)
			{
				byte* ret = GetFileNameNative((byte*)pfilePath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileNameS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filePath)
		{
			fixed (byte* pfilePath = filePath)
			{
				string ret = Utils.DecodeStringUTF8(GetFileNameNative((byte*)pfilePath));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileName([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] string filePath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filePath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filePath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filePath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetFileNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileNameS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] string filePath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filePath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filePath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filePath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetFileNameNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetFileNameWithoutExtNative([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[129])(filePath);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[129])((nint)filePath);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileNameWithoutExt([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			byte* ret = GetFileNameWithoutExtNative(filePath);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileNameWithoutExtS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			string ret = Utils.DecodeStringUTF8(GetFileNameWithoutExtNative(filePath));
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileNameWithoutExt([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ref byte filePath)
		{
			fixed (byte* pfilePath = &filePath)
			{
				byte* ret = GetFileNameWithoutExtNative((byte*)pfilePath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileNameWithoutExtS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ref byte filePath)
		{
			fixed (byte* pfilePath = &filePath)
			{
				string ret = Utils.DecodeStringUTF8(GetFileNameWithoutExtNative((byte*)pfilePath));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileNameWithoutExt([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filePath)
		{
			fixed (byte* pfilePath = filePath)
			{
				byte* ret = GetFileNameWithoutExtNative((byte*)pfilePath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileNameWithoutExtS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filePath)
		{
			fixed (byte* pfilePath = filePath)
			{
				string ret = Utils.DecodeStringUTF8(GetFileNameWithoutExtNative((byte*)pfilePath));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetFileNameWithoutExt([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] string filePath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filePath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filePath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filePath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetFileNameWithoutExtNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetFileNameWithoutExt")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetFileNameWithoutExtS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] string filePath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filePath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filePath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filePath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetFileNameWithoutExtNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetDirectoryPathNative([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[130])(filePath);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[130])((nint)filePath);
			#endif
		}

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetDirectoryPath([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			byte* ret = GetDirectoryPathNative(filePath);
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetDirectoryPathS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] byte* filePath)
		{
			string ret = Utils.DecodeStringUTF8(GetDirectoryPathNative(filePath));
			return ret;
		}

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetDirectoryPath([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ref byte filePath)
		{
			fixed (byte* pfilePath = &filePath)
			{
				byte* ret = GetDirectoryPathNative((byte*)pfilePath);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetDirectoryPathS([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ref byte filePath)
		{
			fixed (byte* pfilePath = &filePath)
			{
				string ret = Utils.DecodeStringUTF8(GetDirectoryPathNative((byte*)pfilePath));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "GetDirectoryPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetDirectoryPath([NativeName(NativeNameType.Param, "filePath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filePath)
		{
			fixed (byte* pfilePath = filePath)
			{
				byte* ret = GetDirectoryPathNative((byte*)pfilePath);
				return ret;
			}
		}
	}
}
